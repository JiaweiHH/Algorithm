## 优先队列

[218. 天际线问题 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/the-skyline-problem/)：城市的天际线是从远处观看城市中所有建筑物形成的轮廓的外部轮廓，给你所有建筑物的位置和高度，返回由这些建筑物形成的天际线，天际线应该是由关键点组成的列表，关键点是水平线段的左端点。👉 [解答](优先队列/218%20天际线问题.cc)

关键点的横坐标只有可能是矩形上面一条边的左端点，并且对于一个关键点来说它的纵坐标应该是包含了该关键点的最大高度。我们可以对矩形的所有横坐标进行排序，然后遍历每一个点，将所有包含该点的矩形放入大根堆中，堆顶的元素的高度就是这个点的纵坐标

需要注意的是，如果前一个坐标已经用过某个纵坐标了，此时对于当前的关键点来说需要忽略当前的关键点

时间复杂度：$O(nlogn)$，空间复杂度：$O(n)$

[264. 丑数 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ugly-number-ii/)：给你一个整数返回第 `n` 个丑数，丑数指的是只包含质因数 2, 3, 5 的正整数。👉 [解答](优先队列/264%20丑数II.cc)

不管是动态规划的解法还是优先队列的解法，本质上思路都是一样的：新的丑数可以从一个已经计算出来的丑数，通过乘以质因数获得

我们可以维护 2, 3 和 5，它们当前和第几个丑数相乘了。每次从相乘的结果中选择最小的一个丑数，然后将该指针往后移动一个位置。如果有多个相乘的结果相同，此时有两种方法：1. 预先计算出相同的结果不存入数组中；2. 通过选择得到的最小丑数，然后去数组中判断有哪些值是相等的，将这些值的指针都往后移动

时间复杂度：$O(n)$，空间复杂度：$O(n)$

[313. 超级丑数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/super-ugly-number/)：超级丑数是一个正整数，满足所有的质因数都在数组 `primes` 中，给你一个整数 `n` 和整数数组 `primes`，返回第 `n` 个超级丑数。👉 [解答](优先队列/313%20超级丑数.cc)

这道题重点是所有的超级丑数都可以从一个较小的超级丑数乘以 `primes[i]` 得到，每个 `primes[i]` 都可以和前面已经得到的超级丑数相乘从而获得一个更大的超级丑数

我们可以使用优先队列维护每个 `primes[i]` 当前乘到第几个前面已经得到的超级丑数了，每次从小根堆中弹出一个元素然后将它乘以下一个超级丑数得到新的丑数 `new_ugly`。为了减少时间复杂度我们需要额外使用一个集合 `set` 来存储当前堆中的元素，如果新的丑数 `new_ugly` 已经出现在集合中了，那么 `primes[i]` 继续乘以下一个超级丑数，直到新得到的丑数不出现在 `set` 中，此时将新的元素插入到堆和 `set` 中。每次弹出元素的时候需要从 `set` 中移除该元素，以节省空间

时间复杂度：需要找到 `n` 个超级丑数，每次找的时候都需要往堆中插入一个新的丑数，堆的大小为 `primes` 数组的大小 `m`，这部分时间复杂度是 $O(nlogm)$，初始构建堆的时候时间复杂度 $O(mlogm)$，最终时间复杂度 $O(max(m, n)logm)$

空间复杂度：维护堆中元素的集合大小为 $O(m)$，存储前 `n` 个丑数的数组大小为 $O(n)$，总的时间复杂度为 $O(m + n)$

[451. 根据字符出现频率排序 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sort-characters-by-frequency/)：给定一个字符串 `s`，根据字符出现的频率对其进行降序排序，返回已经排序的字符串。👉 [解答](优先队列/451%20根据字符出现频率排序.cc)

**堆排序**

每个字符和该字符出现的次数放入大根堆中，每次从堆中弹出一个字符，在 `res` 中追加该字符

时间复杂度：$O(n + klogk)$，其中 n 是字符串 `s` 的长度，k 是字符的种数，空间复杂度：$O(n)$

**桶排序**

将每个字符放到对应出现频率的桶中，然后从大到小遍历每个桶，对于 buckets[i] 中的每个字符，在 `res` 中添加 `i` 个字符

时间复杂度：$O(n + k)$，空间复杂度：$O(n + k)$

[759. 员工空闲时间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/employee-free-time/)：给定员工的 `schedule` 列表，表示每个员工的工作时间。每个员工都有一个非重叠的时间段 `Intervals` 列表，这些时间段已经排好序。返回表示所有员工的共同空闲时间段。👉 [解答](优先队列/759%20员工空闲时间.cc)

**堆 + 贪心**

我们可以将每个员工的第一个空闲时间放到堆中，堆中按照 Interval 的 start 进行排序。使用指针 ptr 表示初始的时间，初始化为堆顶 Interval 的开始时间

每次从堆中弹出 Interval，如果 Interval.start > ptr 则表示 [ptr, Interval.start] 这段时间是所有人的空闲时间。贪心策略的正确性证明：堆中剩余的 Interval 的开始时间必定会大于 cur_Interval.start，所以对于后面的工人来说 [ptr, cur_Interval.start] 必定是他的空闲时间

然后更新 ptr 为 max(ptr, cur_Interval.end)，并将 cur_Interval 对应工人的下一个 Interval 放入堆中

时间复杂度：$O(ClogN)$，C 是所有区间的数量，N 是区间数组的数量；空间复杂度：$O(N)$

**扫描线**

这道题目可以转化为：求和所有区间不相交的区间

我们将所有的区间的开始时间和结束时间抽离出来，给开始时间打上标签 1，结束时间打上标签 -1。然后对所有的时间进行排序，之后遍历这些时间，使用 `prev_time` 记录上一个遍历到的时间，使用 `cnt` 记录当前的计数值。对于开始时间 `cnt += 1`，结束时间 `cnt += -1`，如果某个时刻 `cnt == 0` 则说明从 `prev_time` 到 `cur_time` 是一段空闲时间，记录到结果数组中

时间复杂度：$O(ClogC)$，C 是所有区间的数量；空间复杂度：$O(C)$

[871. 最低加油次数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/)：汽车从起点出发驶向目的地，目的地位于 `target`。途中有很多加油站，加油站 `i` 的位置是 `stations[i][0]`，可以加油 `stations[i][1]` 升。请你计算行驶到目的地所需的最少加油次数，如果不能到达目的地则返回 -1。👉 [解答](优先队列/871%20最低加油次数.cc)

**优先队列 + 贪心**

对于可以到达的加油站我们先选择不加油，将其保存起来。当发现某个加油站不可到达的时候可以选择从保存的加油站中选择汽油最多的一个加油

遍历完所有的加油站之后如果还没有到达目的地，则判断此时是否还有保存的加油站，如果还有的话则依旧选择汽油最多的一个加油，直到可以到达目的地

对于加油站的保存可以使用大根堆

时间复杂度：$O(nlogn)$，空间复杂度：$O(n)$

**动态规划**

$dp[i]$ 表示加油 $i$ 次可以到达的最远距离，我们依次增加对加油站的考虑，则状态转移方程为：$dp[j + 1] = max(dp[j + 1], dp[j] + stations[i][0]), 0 \leq i < n, 0 \leq j \leq i$（`if dp[j] >= stations[i][0]`）

[1675. 数组的最小偏移量 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimize-deviation-in-array/)：给你一个由 `n` 个正整数组成的数组 `nums`，你可以对数组执行任意次数的以下操作：1. 如果元素是偶数，则可以除以 2；2. 如果元素是奇数，则可以乘以 2。定义数组的偏移量是数组中两个元素的最大差值，返回数组在执行某次操作之后可以拥有的最小偏移量。👉 [解答](优先队列/1675%20数组的最小偏移量.cc)

我们可以将所有的奇数操作都转化为偶数操作，具体的实现为：如果 `nums[i]` 是奇数，则将 `nums[i] * 2` 放入大根堆中

维护一个变量 `min_value` 表示堆中元素的最小值，每次从堆中弹出一个元素，计算其和 `min_value` 的差值，并更新 `res`。然后将该元素除以 2 放入堆中，当堆顶元素是奇数的时候此时不能再将最大元素变小，结束操作

时间复杂度：$O(nlogn)$，空间复杂度：$O(n)$

[剑指 Offer 41. 数据流中的中位数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)：设计一个支持以下两种操作的数据结构，1. addNum - 从数据流中添加一个元素到数据结构中，2. findMedian - 返回目前所有元素的中位数。👉 [解答](优先队列/剑指Offer41%20数据流中的中位数.cc)

使用小根堆加大根堆实现这种数据结构，小根堆中存放后面一半的数据，大根堆中存放前面一半的数据。如果数据的个数是奇数，则小根堆中比大根堆中多存放一个元素

添加元素的时候，如果小根堆为空则添加到小根堆中，否则的话获取小根堆的堆顶元素

1. 如果 `num` 大于等于堆顶元素，则添加到小根堆中。此时还需要判断小根堆中的元素个数是否大于 `(sz + 1) / 2`，如果满足该条件则将堆顶元素弹出放到大根堆中；
2. 如果 `num` 小于小根堆的堆顶元素，则将元素放到大根堆中，并判断大根堆中的元素个数是否大于 `sz / 2`，如果是的话将堆顶元素放到小根堆中

时间复杂度分析：addNum 操作的时间复杂度是 `O(logn)`，findMedian 操作的时间复杂度是 `O(1)`

空间复杂度：`O(n)`

### 前 K 个元素

[215.数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)：给你一个数组 `nums`，返回其中第 `k` 个最大整数。👉 [解答](优先队列/215%20数组中的第k个最大元素.cc)

1. 堆排序。建立大顶堆之后进行 `k - 1` 次调整（要求手写对排序）
2. 快速选择。利用快速排序的 `partition`，时间复杂度 $O(n)$

[347. 前 K 个高频元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/top-k-frequent-elements/)：给你一个整数数组 nums 和一个整数 k，请你返回其中出现的频率前 k 高的元素，你可以按任意顺序返回答案。👉 [解答](优先队列/347%20前K个高频元素.cc)

和 **215题** 一样

[703. 数据流中的第 K 大元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)：设计一个找到数据流中第 `k` 大元素的类。👉 [解答](优先队列/703%20数据流中的第K大元素.cc)

和 **215题** 一样

1. 堆：大小为 K 的小根堆保存前 K 大的元素
2. 快速选择

[973. 最接近原点的 K 个点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/k-closest-points-to-origin/)：给定一个数组 `points`，找出离原点最近的 `k` 个点。👉 [解答](优先队列/973%20最接近原点的K个点.cc)

1. 堆
2. 快速选择

[面试题 17.14. 最小K个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/smallest-k-lcci/)：设计一个算法，找出数组中最小的 `k` 个数，以任意顺序返回这 `k` 个数均可。👉 [解答](优先队列/面试题17.14%20最小K个数.cc)

和 **215题** 一样

1. 快速选择：分割出前 `k` 个元素。时间复杂度：`O(n)`，空间复杂度：`O(logn)`
2. 堆：使用大小为 `k` 的大根堆保存前 `k` 个元素。时间复杂度：`O(nlogk)`，空间复杂度：`O(k)`
