## 二分

### 旋转数组

[33.搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)：整数数组 `nums` 按升序排列，数组的值互不相同。对 `nums` 在某一个位置 `k` 上进行旋转之后的结果是 `[nums[k], nums[k + 1], ..., nums[n - 1], nums[0], nums[1], ..., nums[k - 1]`。现在给出旋转之后的数组 `nums` 和一个整数 `target`，如果 `nums` 中存在 `target` 返回 `target` 的下标，否则返回 -1。要求时间复杂度为 `O(log n)`，👉 [<u>搜索旋转排序数组</u>](二分/33%20搜索旋转排序数组.cc)

1. 判断 `nums[mid]` 是在第一段区间还是在第二段区间
2. 如果 `nums[mid]` 在第一段区间，判断 `nums[l] <= target < nums[mid]` 是否成立，如果成立的话 `l = mid + 1`，否则 `r = mid - 1`
3. 如果 `nums[mid]` 在第二段区间，判断 `nums[mid] <= target <= nums[r]` 是否成立，如果成立的话 `l = mid + 1`，否则 `r = mid - 1`

最后返回 `r < 0 || nums[r] != target ? -1 : r`

**进阶：如果在旋转一次应该要怎么做，做法还是一样的，无论旋转几次最多只有两段递增序列**

[81.搜索旋转排序数组II]([81. 搜索旋转排序数组 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/))：与 **33题** 的区别在于，现在数组中存在重复的元素。👉 [<u>搜索旋转排序数组II</u>](二分/81%20搜索旋转数组II.cc)

1. 处理方法和 **154题** 相同，跳过所有 `left` 重复的元素，然后 `right` 再跳过和 `left` 重复的元素。之后就是和 **33题** 相同的解法了。最坏的情况下时间复杂度 `O(n)`，此时需要遍历跳过所有的元素
2. 在 **33题** 的基础上，增加判断 `nums[mid] == nums[r]` 的情况，因为当 `nums[mid] == nums[r]` 的时候，我们并不能确定 `mid` 是在第一段区间还是在第二段区间，但是我们知道即便 `nums[r]` 是需要找的值，它也有一个替代品，所以这个时候 `--r`
   - 【一些细节】只有当 `nums[mid] == nums[r] && r != l` 的时候才执行 `--r`，当 `r == l` 的时候放到 **33题** 的处理代码中处理就好了，不然的话会造成只有一个元素的时候 `r` 并不是指向` target`

[面试题 10.03. 搜索旋转数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-rotate-array-lcci/)：搜索旋转数组，找到数组中的某个元素，如果元素出现多次，则返回最小的索引值。👉 [解答](二分/面试题10.03.搜索旋转数组.cc)

这题和 **81题** 的区别在于，本题需要返回重复元素的最小下标，而 **81题** 只需要判断是否存在这个元素就可以了

**两段式搜索**

这里集成了：1. 找到数组中旋转位置的下标；2. 给定一个 target 找到 target 的最小下标，这两个问题的方法

1. 首先找到数组旋转的下标，可以对 **154题** 的代码稍作修改（原本这题的代码只保证找到数组中的最小元素值，这个值既可能是 nums[0]，也可能是 nums[routate]）
2. 判断 target 位于哪一段区间
3. 二分查找 target

```c++
// 找到数组中的旋转位置下标
int n = arr.size();
int l = 0, r = n - 1, start_idx = 0;
while (l <= r) {
  int mid = (l + r) / 2;
  if (arr[mid] > arr[r])
    l = mid + 1;
  else if (arr[mid] < arr[r]) {
    start_idx = max(start_idx, r + 1);
    r = mid;
  } else {
    --r;
  }
}
start_idx = start_idx == n || arr[start_idx] != arr[l] ? l : start_idx;
```

**一遍搜索**

直接在 **81题** 的基础上修改，增加判断 `arr[l] == target` 的时候直接返回 `l`，以及 `arr[mid] == target` 的时候 `r = mid`。其余的保持和 **81题** 相同（`nums[mid] == nums[r] && r != l` -> `nums[mid] == nums[r]`）

[153.寻找旋转排序数组中的最小值]([153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/))：给你一个数组 `nums`，数组中不包含重复元素，它是由一个有序数组旋转若干次得到的，请找出原数组中的最小值。👉 [<u>寻找旋转排序数组中的最小值</u>](二分/153%20寻找旋转排序数组中的最小值.cc)

直接使用二分查找，如果 `nums[mid] > nums[r]` 说明 `mid` 在左边的递增区间上，此时 `l = mid + 1`。如果 `nums[mid] <= nums[r]` 说明 `mid` 此时在右边的递增区间上，由于 `mid` 有可能是最小值，因此让 `r = mid`。循环的出口是 `l < r`

[154.寻找旋转排序数组的最小值II]([154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/))：这题相比于 **153题** 的区别在于现在数组中可能会包含重复的元素。👉 [<u>寻找旋转排序数组的最小值II</u>](二分/154%20寻找旋转排序数组的最小值II.cc)

下面提供两种二分查找的方法

1. 自己写的方法。跳过 `left` 左端的所有重复元素，然后判断 `left` 和 `right` 是否一样，如果一样的话 `right` 向左移动。之后就是 **153题** 的解法了
2. 直接在 **153题** 的基础上修改，唯一的区别在于现在当 `nums[mid] = nums[r]` 的时候并不能确定应该丢弃左半区间还是丢弃右半区间，但是唯一可以确定的是这个时候即便 `nums[r]` 是最小值，它也有替代值，因此 `--r`。其余的都和 **153题** 一样，当 `nums[mid] > nums[r]` 的时候 `l = mid + 1`。当 `nums[mid] < nums[r]` 的时候，由于 `nums[mid]` 也有可能是最小值，因此 `r = mid`。循环的出口是 `l < r`

### 对题目给出的目标属性进行二分查找

[373. 查找和最小的 K 对数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)：给你两个以升序排列的整数数组 `nums1` 和 `nums2`，以及一个整数 k，请你找到和最小的 k 对数对，并返回它们。👉 [解答](二分/373%20查找和最小的K对数字.cc)

这道题类似 **378题**

优先队列。我们可以把 `[0, {0, 1, ..., nums2.size() - 1}], [1, {0, 1, ..., nums2.size() - 1}], [nums1.size() - 1, {0, 1, ..., nums2.size() - 1}]`，看成 m 个链表，然后转化为 m 个链表求出最小的 k 对数对。这样初始的时候将每个链表的第一个元素放入小根堆，然后每次弹出一个元素，并将它的下一个元素放入堆中。循环条件：`while (k-- && !heap.empty()）`

时间复杂度：O(klogn)，n 是 nums2 的大小，空间复杂度 O(n)

同 **378题**，也可以使用二分查找。我们只需要找到满足「小于等于某个目标值的数对和的个数刚好大于等于 k」这样的数对和 `target_sum` 就可以了，然后从数组中首先将和小于 `target_sum` 的数对存入答案中，再按照下标索引的顺序将等于 `target_sum` 的数对和存入答案中

> 必须先存入小于 target_sum，再存入等于 target_sum，因为数对和等于 target_sum 的数对的个数可能会大于题目要求的 k。这个时候只有将小于 target_sum 的答案全都保存下来了，才可以考虑等于 target_sum 的答案

[378. 有序矩阵中第 K 小的元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)：给你一个 n*n 的矩阵，其中每行和每列都是升序的，请你找出矩阵中第 k 小的元素值。👉 [有序矩阵中第K小的元素](二分/378%20有序矩阵中第K小的元素.cc)

1. 对所有的元素排序，然后返回第 k 小的元素。时间复杂度 O(n^2 * logn)，空间复杂度 O(n^2)
2. 优先队列 + k 指针。可以将 n*n 的矩阵看成是 n 个有序的数组，我们将每个数组的第一个「元素」放入到堆中，每次从堆中弹出最小的元素，然后将它的下一个元素压入堆中，当我们弹出了 k-1 个元素的时候，此时堆顶元素就是第 k 小的元素。时间复杂度 O(klogn)，空间复杂度 O(n)
3. 二分查找。我们确定二分查找的边界为 `[matrix[0][0], matrix[n - 1][n - 1]]`，然后每次取区间中间的值，在矩阵中找到有多少个元素是小于等于这个值的。具体的查找过程为：从最后一行出发，如果元素值小于目标值，那么就往右走并统计此时有 x + 1 个元素是小于目标值的（x 是此时所在的行号），如果元素值大于目标值就往上走。最后如果小于等于目标值的数量要大于等于 k，则右边界收缩，否则左边界收缩

[668. 乘法表中第k小的数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/)：找到一个 m*n 的乘法表中第 k 小的数。👉 [解答](二分/668%20乘法表中第K小的数.cc)

解法和 **378题** 相同，确定二分查找的边界 `[1, m*n]` 在乘法表中恰好有 k 的数字小于等于某个值的目标值 target 就可以了

这道题不需要建立二维数组，因为对于乘法表来说，某一行小于等于某个值的元素个数为 `min(target / i, n)`

[719. 找出第 k 小的距离对 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)：给定一个整数数组，返回所有数对之间的第K个最小距离，(A, B) 的距离被定义为 abs(A - B)。👉 [解答](二分/719%20找出第K小的距离对.cc)

通过二分查找找到某个距离 target，满足恰好有 k 个数对距离小于等于 target，此时返回 target 就是最后的答案

首先对 `nums` 排序，确定二分查找的边界为 `[0, nums[n - 1] - nums[0]]`，每次通过滑动窗口计算距离小于等于 `mid` 的数对的个数，如果 `count(nums, mid) >= k` -> `r = mid - 1`，否则的话 `l = mid + 1`

count 函数的计算方法有两种

1. 采用滑动窗口计算：当 `nums[r] - nums[l] >= target` 的时候需要收缩窗口。并且对于一个给定的 `r`，满足要求的数对的另一个值的个数是 `r - l`，即窗口中所有以 `r` 为第二个元素的数对都满足要求（因为 `nums[r] - nums[l] <= target`）
2. 采用前缀和计算：使用数组 `prefix` 表示对于一个给定的值 `v`，`prefix[v]` 表示数组中小于等于 `v` 的元素有多少个。另外对于一个数组中给定的元素 `v`，`repeat[v]` 表示 `v` 最后出现的位置。这样对于给定的 `mid` 来说，距离小于等于 `mid` 的数对的数量就等于 `(prefix[nums[i] + mid] - prefix[nums[i]]) + repeat[nums[]] - i`，其中前半部分表示不同元素组成的数对的个数，后半部分表示相同元素组成的数对个数

最后给出时间复杂度：

1. 如果采用滑动窗口计算 count 函数：O(nlog diff + nlogn)，log diff 是二分查找的次数，diff 是数组中最大值和最小值的差值，每次二分查找滑动窗口的时间复杂度都是 O(n)，因此整个查找的过程时间复杂度是 O(nlog diff)，最后再加上排序的时间复杂度
2. 如果采用前缀和计算 count 函数：O(max_value + diff + nlog diff + nlogn)，其中 diff 为数组中最大值和最小值的元素之差，max_value 为数组中的最大值，计算 prefix 数组的时候时间复杂度是 O(max_value + max_value - min_value)，排序的时间复杂度是 O(nlogn)，二分查找的时间复杂度是 O(nlog diff)，所以最后的时间复杂度是 O(max_value + diff + nlog diff + nlogn)

空间复杂度：

1. 如果采用滑动窗口计算 count 函数：O(1)
2. 如果采用前缀和计算 count 函数：O(max_value + diff + n)

[786. 第 K 个最小的素数分数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)：给你一个按递增顺序排列的数组 `arr` 和一个整数 `k`。数组 `arr` 由 1 和若干素数组成，其中所有整数互不相同。对于每对满足 `0 <= i < j < arr.length` 的 `i` 和 `j`，可以得到分数 `arr[i] / arr[j]`，那么第 `k` 个最小的分数是多少呢，返回组成这个分数的 `arr[i]` 和 `arr[j]`。👉 [解答](二分/786%20第K个最小的素数分数.cc)

**二分查找**

对于所有可以组成的分数，我们可以将它排列成矩阵的一半，其中第 `i` 行是所有以 `arr[i + 1]` 为分母的分数，第 `i` 行第 `j` 列表示的分数是 `arr[j] / arr[i + 1]`，这样以来该矩阵满足从左到右单调递增、从上到下单调递减，此时这道题就转化为了 **378题**

将二分查找的左右边界设置为 `[0, 1]`，对于每个 `mid` 我们计算出小于等于这个浮点数的分数有多少个（`cnt`），并且在沿着矩阵查找的时候记录下 `res_x` 和 `res_y`，满足 `res_x / res_y` 是小于等于 `mid` 的最大分数

如果 `cnt == k`，返回 `{res_x, res_y}`；如果 `cnt < k`，`l = mid`；如果 `cnt > k`，`r = mid`

时间复杂度：O(nlogC)，n 是数组的长度，每次二分查找需要 O(n) 的时间复杂度；C 是数组的元素的最大值，最多需要进行 logC^2 的查找次数。所以最后的时间复杂度是 O(nlogC)

空间复杂度：O(1)

**堆**

将所有 `arr[i] / arr[n - 1]` 看成一个链表，链表的第一个元素就是 `arr[i] / arr[n - 1]`，链表的下一个元素是 `arr[i] / arr[n - 2]`，因此我们可以得到 `n - 1` 个链表。此时这道题就变成了 k 个有序链表求前 ? 最小的值，可以将所有链表的第一个元素放到堆中，每次弹出一个节点然后将它的下一个节点放入堆中

时间复杂度：O(klogn)，需要弹出 k 次，每次弹出之后插入元素的时间复杂度是 O(logn)

空间复杂度：O(logn)

[875. 爱吃香蕉的珂珂 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/koko-eating-bananas/)：有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉，警卫将在 `h` 小时候回来，珂珂吃香蕉的速度是 `k`，每个小时会选择一堆香蕉从中吃掉 `k` 根，如果这堆香蕉少于 `k` 根则会吃掉所有香蕉。请你计算珂珂在 `h` 小时之内吃完所有香蕉的最小速度 `k`。👉 [解答](二分/875%20爱吃香蕉的珂珂.cc)

对速度 `k` 进行二分查找，每次计算以 `mid` 速度吃完所有香蕉所需要的时间 `cnt`。如果 `cnt <= h`，则让 `r = mid - 1`，否则的话 `l = mid + 1`

时间复杂度：$O(nlogW)$，W 是所有堆中最多的香蕉数量

[1044. 最长重复子串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-duplicate-substring/)：给你一个字符串 `s`，返回任意一个具有最长长度的重复子串，如果 `s` 中不包含重复子串则返回 ""。👉 [解答](二分/1044%20最长重复子串.cc)

重复子串的长度最短为 1，最长为 `s.size()`，随着长度的增加出现重复的次数会减少，所有具有单调性。因此我们可以使用二分查找，找出最大的重复子串的长度

查找的方法可以直接暴力查找，时间复杂度是 O(nL)，L 是当前查找的子串的长度，如果采用暴力查找会超时。我们可以使用「滚动哈希」的方法进行优化：例如当前查找的子串长度为 `L`，我们可以 `s` 中所有长度为 `L` 的子串进行编码，具体的编码规则为 $c_0 * a^{L-1} + c_1 * a^{L - 2} + ... + c_{L - 1} * a^1$，`ci` 是子串中的字符，`a` 是随机的一个底数。如果有两个子串的编码相同，就说明出现了重复的子串，我们记录下当前子串的长度和起始位置，然后返回就可以了

如果前一个子串的编码为 $hash\_val$，则当前子串的编码为 $hash\_val * index - a^{L - 1} * s_{i - L} + s_i$

尽管上面说了编码的方法，但是实际编码的时候可能会溢出，因此需要取模，但是取模了之后不同子串的编码就会重复。此时可以使用两个底数计算子串的哈希值（两个哈希值来判断编码是否相同），以此来降低哈希冲突的概率，对于取模我们可以使用 `unsigned` 类型的整数，它们在溢出之后会自动取模

> `pair<>` 类型使用 `unordered_set` 的时候需要自己手动实现 hash function 函数对象，具体参考本题的代码
>
> [std::pair作为unordered_map的key_给我一瓶AC钙的博客-CSDN博客_pair作为map的key](https://blog.csdn.net/TDD_Master/article/details/99083702)

### 「...... 最大值最小」或「......最小值最大」

[410. 分割数组的最大值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/split-array-largest-sum/)：给定一个非负整数数组 `nums` 和一个整数 `m`，你需要将这个数组分割成 `m` 个非空子数组，使得每个**子数组各自和**的最大值最小。👉 [解答](二分/410%20分割数组的最大值.cc)

**采用动态规划解决**

「数组分割为 m 段，求......」一般都可以用动态规划解决

`dp[i][j]` 表示将数组的前 `i` 个元素分割成 `j` 段，能获得的各自和最大值的最小值（后面简称最优值）。该问题可以转化为子问题：将前 `k` 个元素（`k < i`）分割成 `j - 1` 段，然后 `[k, i - 1]` 分割为第 `j` 段。所以 $dp[i][j] = min(max(dp[k][j - 1], sum(nums, k, i - 1))), j - 1 \leq k < i, j = min(i, m)$，在求 `sum` 的时候可以使用前缀和加速

时间复杂度：O(mn^2^)，空间复杂度：O(n * m)

**二分查找 + 贪心**

「使......的最大值尽可能小」一般可以用二分查找解决

对于数组 `nums` 来说，子数组和最大值的最小值的范围是 `[max_val,  sum_val]`，对于每一个区间内的值 `target` 可以采用贪心的方法计算出可以划分出子数组的数量：从前往后遍历 `nums`，如果当前连续子数组的和 `sum` 加上 `nums[i]` 大于 `target`，则增加子数组的数量，并让 `sum = nums[i]`，最后可以统计出以 `target` 为最大值可以划分出的子数组的数量

我们的目标是找到最小的 `target`，使得划分出的子数组的数量等于 `m`。划分子数组的数量随着 `target` 的变大是单调递减的，因此可以用二分查找找到最小的 `target`

[475. 供暖器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/heaters/)：给出位于一条水平线上的房屋 `houses` 和供暖器 `heaters` 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。👉 [解答](二分/475%20供暖器.cc)

**二分**

对所有的供暖器进行排序，然后遍历每一个房屋，找到距离它最近的两个供暖器，房屋距离这两个供暖器距离的最小值就是这个房屋所需要的最小加热半径。最后取所有房屋最小加热半径的最大值作为供暖器的最小加热半径

我们可以使用二分查找找到房屋左侧最近的供暖器的下标 `idx`，此时 `idx + 1` 就是房屋右侧的第一个供暖器，通过计算这两个供暖器距离房屋的距离决定该房屋需要的最小加热半径

时间复杂度：$O(nlogn + mlogn)$，$m$ 是房屋的数量，$n$ 是供暖器的数量，空间复杂度：$O(logn)$

**双指针**

前面的二分方法中只对 `heaters` 数组进行了排序，我们也可以对 `heaters` 和 `houses` 数组都进行排序，然后依旧是找到每个房屋最近的供暖器

此时假如距离房屋 $i_0$ 最近的供暖器是 $j_0$，那么对于在 $i_0$ 右侧的房子 $i_1(i_1 > i_0)$ 距离它最近的供暖器 $j_1$ 必定满足 $j_1 \geq j_0$，因此可以使用双指针遍历 `houses` 和 `heaters`

时间复杂度：$O(mlogm + nlogn)$，空间复杂度：$O(logm + logn)$

[774. 最小化去加油站的最大距离 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimize-max-distance-to-gas-station/)：整数数组 `stations` 表示水平数轴上各个加油站的位置，给你一个整数 `k` 请你在数轴上增设 `k` 个加油站，加油站可以放在数轴上的任何位置而不必放在整数位置上。请你返回增设 ` k` 个加油站之后，相邻两个加油站之间的最大距离的最小值。👉 [解答](二分/774%20最小化去加油站的最大距离.cc)

**二分查找**

**410分割数组** 那题有提到过，「......最大值的最小值」通常可以使用二分查找，本题采取和 **410题** 相同的思路

对于每一个给定的相邻加油站之间的「最大距离的最小值」`target`，计算需要增设多少个新的加油站才可以达到该要求，每两个相邻加油站需要增设的新加油站的数量是 `diff/target`，然后判断整体上新增的加油站数量 `count` 是否超过 `k` 个。对于给定的 `target` 关于新增加油站数量 `count` 是单调递减的，因此可以通过二分查找计算「最大距离的最小值」，如果 `count <= k` 则收缩右边界 `r = mid`，否则的话收缩左边界 `l = mid`

由于是浮点数二分查找永远不会终止，所以在 `r - l < 10^-6` 的时候退出循环，返回此时的 `l` 或者 `r` 就是最终「相邻加油站之间距离最大值的最小值」

时间复杂度：$O(NlogW)$，其中 W 是数组的最大值，空间复杂度：$O(1)$

**堆**

堆中存放 `<diff_i, count_i>` 表示第 `i` 个原始加油站间隔的距离是多少，当前这个间隔里面有多少个加油站。每次从堆中弹出 `diff_i/count_i` 最小的元素，然后增加一个加油站数量，放回堆中

时间复杂度：$KlogN$，空间复杂度：$O(N)$。本题该方法会超时

**动态规划**

定义 $dp[i][j]$ 表示增加 `j` 个加油站之后前 `i` 个间隔获得的最小的最大距离，这个问题可以分解为子问题：将 `x` 个加油站放在第 `i` 个间隔，那么剩余的 `j-x` 个加油站就需要放到前 `i-1` 个间隔中，所以可以得到状态转移方程：
$$
dp[i][j] = min(diff[i] / x, dp[i - 1][j - x]), 0 \leq i \leq n-1, 0 \leq j \leq k
$$
时间复杂度：$O(NK^2)$，空间复杂度：$O(NK)$

[1011. 在 D 天内送达包裹的能力 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)：给出一组包裹，`weights[i]` 表示第 `i` 个包裹的重量，返回能在 `days` 天内将传送带上的所有包裹送达的船的最低运载能力。👉 [解答](二分/1011%20在D天内送达包裹的能力.cc)

这道题目的意思等价于：将数组 `weights` 分成 `days` 段，求出每段数组和的最大值的最小值。**410题** 做的就是这个事情，因此这道题和 **410题** 完全一样

[1231. 分享巧克力 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/divide-chocolate/)：你有一大块巧克力，它由一些甜度不完全的小块组成，我们用数组 `sweetness` 表示每一小块的甜度，你打算和 `K` 名朋友一起分享巧克力，所以需要将巧克力分为 `K + 1` 块，你将会吃掉总甜度最小的一块，请你找出最佳的切割策略，使得你所分得的巧克力的总甜度最大，并返回这个最大总甜度。👉 [解答](二分/1231%20分享巧克力.cc)

典型的「......最小值最大」，这道题的解法类似于 **1552题**。我们需要找到甜度最小的巧克力 `res`，使得可以将所有的巧克力分为甜度大于等于 `res` 的 `K + 1` 块

确定二分查找的边界为 $[min_{sweetnexx}, sum_{sweetness}]$，对于最小甜度 `mid` 来说，计算可以将巧克力分为 `cnt` 块。如果 `cnt > k + 1` 则表明此时的最小甜度太小了，因此 `l = mid + 1`；如果 `cnt < k + 1` 则表明此时的最小甜度太大了，因此 `r = mid - 1`；如果 `cnt == k + 1` 由于我们需要尽可能的让最小甜度最大，因此 `l = mid + 1`

最后二分查找结束的时候 `l` 就是满足题目要求的「最小甜度的最大值」

时间复杂度：$O(NlogS)$，二分查找需要进行 $logS$ 次，每次需要遍历 `sweetness` 数组，空间复杂度：$O(1)$

[1552. 两球之间的磁力 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/magnetic-force-between-two-balls/)：给你 `n` 个篮子，`m` 个球，请将 `m` 个球放入 `n` 个篮子中使得相邻两个球之间最小距离最大化。👉 [解答](二分/1552%20两球之间的磁力.cc)

「......最小值的最大值」这类问题和「......最大值的最小值」是一样的，都可以使用二分查找来解决，本题是求两个之间距离最小值的最大值

首先对篮子的位置进行排序，这样相邻两个球之间距离的左右边界就是 `[1, position[n - 1] - position[0]]`，对于某个距离 `mid`，我们可以统计当按照最小距离是 `mid` 的时候篮子中最多可以放几个球。具体的统计方法为贪心的思想：第一个球放在第一个篮子中，第二个球放在距离刚好大于等于第一个球的篮子中，以此类推

由于最多可以放置的球的数量随最小距离的值是单调递减的，如果对于距离 `mid` 统计出来可以放置的球的数量 `count >= m` 则尝试将距离增大，即 `l = mid + 1`，否则的话将距离减小，即 `r = mid - 1`

最后二分查找结束时候 `r` 就是最小距离的最大值

时间复杂度：$O(nlogn + nlogK)$，其中 $nlogn$ 是对篮子排序的时间复杂度；$K$ 是两个篮子距离的最大值，二分查找的次数是 $logK$ 次，每次需要遍历所有的篮子，因此二分查找总的时间复杂度是 $nlogK$，最终的时间复杂度就是 $nlogn + nlogK$

空间复杂度：$O(logn)$，仅仅是排序的空间复杂度

### 子序列

[300.最长递增子序列]([300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-increasing-subsequence/))：给你一个整数数组 `nums`，找到其中最长严格递增的子序列长度。👉 [<u>最长严格递增子序列</u>](二分/300%20最长递增子序列.cc)

进阶：你可以将算法的时间复杂度降低到 `O(nlogn)` 吗

1. 最直接的使用动态规划来解决该问题。`dp[i]` 表示以 `nums[i]` 为结尾的子序列的最长长度。计算 `dp[i]` 的时候需要向前寻找 `j` 满足 `nums[j] < nums[i], dp[i] = max(dp[i], dp[j] + 1)`。时间复杂度 `O(n^2)`
2. 贪心 + 二分。贪心策略：要使得子序列尽可能的长，只要我们的子序列上升的足够慢即可。使用数组 `vec[len]` 表示长度为 `len` 的子序列的最后一个元素值。遍历 `nums` 数组，如果 `nums[i] > vec[len]`，此时子序列的长度可以增加一个 `vec[++len] = nums[i]`；否则的话就需要在 `vec` 数组中找到第一个大于 `nums[i]` 的元素，更新其值为 `nums[i]`（保证子序列上升的足够慢）

[354. 俄罗斯套娃信封问题 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/russian-doll-envelopes/)：给你一个二维整数数组 `envelopes`，其中 `envelopes[i] = [wi, hi]`，表示第 `i` 个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个时候就可以放进另一个信封里面。请计算最多能有多少个信封能组成一组套娃信封。👉 [解答](二分/354%20俄罗斯套娃信封问题.cc)

我们可以考虑当 `wi <= wj, i < j` 的时候，这个时候由于前面信封的宽度一定是小于等于后面信封的，那么前面信封能不能装进后面信封的问题就变成了一个最长子序列的问题。我们对 `hi` 需要按照递减的顺序排列，否则的话就会将宽度一样的信封装在一起了

因此该问题的解决方法如下：

1. 对所有的信封按照宽度从小到大，高度从大到小排序
2. 转变为一个最长递增子序列问题，可以使用动态规划或者二分查找 + 贪心的方法解决

### 子串/子数组

[1574. 删除最短的子数组使剩余数组有序 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/)：给你一个整数数组 `arr`，请你删除一个连续的子数组（可以为空），使得剩下的元素是非递减的，请你返回最短子数组的长度。👉 [<u>删除最短的子数组使剩余数组有序</u>](二分/1574%20删除最短的子数组使剩余数组有序.cc)

首先找到左边开始递减的位置 `left`，以及右边开始递减的位置`right`。然后查找 ` arr[:left]` 在 `arr[right:]` 中出现的位置 `idx`， `idx - i - 1` 即为要删除的长度

注意初始的时候 `res` 需要设置为 `r`，表示默认 `r` 左边的子数组都需要删除

### 重复数问题

[169.多数元素](https://leetcode-cn.com/problems/majority-element/)：给定一个大小为 `n` 的数组，找到其中的多数元素，即出现次数大于 `n/2` 的元素。👉 [<u>多数元素</u>](hot100/169%20多数元素.cc)

有以下几种方法可以解决该问题：

1. 哈希。使用一个 `unordered_map<int, int>` 记录每个元素出现的次数，如果一个元素出现的次数大于 `n/2` 则返回该元素。时间复杂度 `O(n)`，空间复杂度 `O(n)`
2. 排序。对 `nums` 数组排序，然后返回数组的中间元素，即 `nums[nums.size()/2]`。时间复杂度 `O(nlogn)`，空间复杂度 `O(logn)`
3. 分治。如果元素 `target` 为众数，那么将 `nums` 分为两部分，`target` 必定为某一部分的众数，可以用反证法证明该理论，即假设 `target` 不是这两部分的众数，最后可以得出 `target` 不是 `nums` 的众数，与假设矛盾
   - 记左半部分的众数为 `target1`，右半部分区间的众数为 `target2`。此时只需要遍历左半部分区间和右半部分区间统计 `target1` 的数量和 `target2` 的数量即可知道 `target1` 和 `target2` 哪个是 `nums` 的众数了
   - 当区间长度为 `1` 的时候，直接返回该元素即可
   - 时间复杂度 `O(n)`，空间复杂度 `O(1)`
4. 投票。如果已知某一个数是众数，那么我们遇到该数的时候对计数值 `count` 加一，遇到不是该数的时候对计数值减一，最后 `count` 的值必定大于 0。基于该理论，初始时 `count = 0`。然后开始扫描数组元素，如果 `count = 0` 则目标数 `target = nums[i]` 并增加 `count`。如果后续遍历到和 `target` 相等的元素则 `count++`，否则 `count--`。时间复杂度 `O(n)`，空间复杂度 `O(1)`

[268. 丢失的数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/missing-number/)：给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums`，请找出 `[0, n]` 这个范围内没有出现在数组中的那个数。👉 [解答](二分/268%20丢失的数字.cc)

**排序 + 二分**

先对 `nums` 数组进行排序，如果下标 `i` 对应的数字 `i` 丢失了，此时 `nums[i] > i`，因此可以使用二分查找找到第一个满足 `nums[i] > i` 的下标，该下标就是丢失的数字

时间复杂度：$O(nlogn)$，空间复杂度 $O(logn)$

**位运算**

首先将 `nums` 数组中的所有数亦或到一起，然后再亦或 `[0, n]` 中的数，最后的结果就是丢失的数字

[剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)：一个长度为 `n - 1` 的递增排序的数组中，所有的数字都是唯一的，并且每个数字都在反胃 0 到 n - 1 之间，请你找出 0 到 n - 1 之间不再数组中的那个数字。👉 [解答](二分/剑指Offer%2053-II%200~n-1中缺失的数字.cc)

二分查找找到第一个 `nums[i] > i` 的那个下标就是缺失的那个数字

[287.寻找重复数]([287. 寻找重复数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-the-duplicate-number/))：给定一个包含有 `n + 1` 个整数的数组 `nums`，其数字都在 `[1, n]` 范围内，因此至少存在一个重复的数字。假设 `nums` 只有一个重复的整数，找出这个整数，你的解决方案必须不修改数组 `nums` 并且只用常量级 `O(1)` 的额外空间。👉 [<u>寻找重复数</u>](287%20寻找重复数.cc)

**二分查找**

假设重复的数字是 `target`，使用 `cnt[i]` 表示数组中小于等于 `i` 的元素出现的次数。因此当 `1 <= i <= target - 1` 的时候，`cnt[i] <= i`；当 `i >= target` 的时候，`cnt[i] > i`

- 最简单直接的就是 `[1, target - 1]` 重的数字都出现了一次，然后 `target` 出现了两次，然后 `[target + 1, n]` 之间的数字出现了一次。这样的话，当 `i < target` 的时候，`cnt[i] = i`；当 `i == target` 的时候，`cnt[i] > i`；当 `i > target` 的时候，`cnt[i] > i`
- 然后如果 `target` 出现了超过一次，那么 `[1, n]` 中的数字必定有些数字没有出现。如果这些数字中有小于 `target` 的数字，那么当 `i < target` 的时候 `cnt[i] < i`；如果这些数字中有大于 `target` 的数字，那么当 `i > target` 的时候 `cnt[i]` 依旧大于 `i`

综上所述，只要 `i < target`，`cnt[i] <= i`；只要 `i >= target`，`cnt[i] > i`

所以 `cnt` 数组形成了一个单调递增的序列，前面有一部分满足 `cnt[x] <= x`，后面一部分满足 `cnt[x] > x`，我们的目标就是找到这个分界点，即第一个满足 `cnt[x] > x` 的 `x`。因此可以使用二分查找完成该任务

时间复杂度 `O(nlogn)`

**位运算**

本题还可以使用位运算的思想。对于一个给定的数字集，每个数字只出现一次，这样的话可以知道每一个比特上面出现的 `1` 的总数

我们假设原来 `[1, n]` 中第 `bit` 个比特上出现的 `1` 的总数为 `x`，现在将 `[1, n]` 考虑又加进来一个数字 `target`

- 如果 `target` 第 `bit` 个比特上是 `0`，如果 `target` 在 `nums` 中只出现两次，那么最后第 `bit` 位上的 `1` 的总数 `y` 满足 `y = x`；如果 `target` 在 `nums` 中出现了大于两次（此时需要替换某些元素），那么最后第 `bit` 位上的 `1` 的总数 `y` 满足 `y <= x`。因此最后满足 `y <= x`
- 如果 `target` 第 `bit` 个比特上是 `1`，如果 `target` 在 `nums` 中只出现了两次，那么最后第 `bit` 位上 `1` 的总数 `y` 满足 `y > x`；如果 `target` 在 `nums` 中出现了大于两次（此时需要替换某些元素），那么最后第 `bit` 位上 `1` 的总数 `y` 满足 `y > x`。因此最后满足 `y > x`

综上所述，我们只需要统计第 `bit` 位上 `1` 的个数 `y`，和原来的 `[1, n]` 上第 `bit` 位上 `1` 的个数 `x` 进行对比，如果 `y > x` 就说明 `target` 第 `bit` 位的值为 `1`，否则就是 `0`。最后按位拼接到一起就可以得出 `target` 的值

时间复杂度 `O(nlogn)`，其中 `logn` 是求出 `n` 的最大比特位的值 `bitmax`，然后循环 `bitmax`

**快慢指针**

本题还可以使用双指针（快慢指针）的方法来解决。首先如果不存在重复的元素例如 `[1, 3, 4, 2]`，以下标 `n` 和 `nums[n]` 建立映射我们可以得到 `1->3->2->4->nullptr`。现在出现了一个重复的元素，此时必定会存在环

[540. 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)：给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，只有一个元素只会出现一次，请你找出这个元素，要求必须使用 $O(logn)$ 的时间复杂度和 $O(1)$ 的空间复杂度。👉 [解答](二分/540%20有序数组中的单一元素.cc)

当没有单一数字的时候，对于每一个元素，第一个出现的位置是在奇数位置，第二个出现的位置是在偶数位置。一旦出现一个单一元素，该元素后面的每对重复元素，第一个元素出现在偶数位置，第二个元素出现在奇数位置

所以我们可以利用这个特性来判断给定下标 `mid` 和单一元素的左右关系，通过二分查找确定单一元素的下标，得到单一元素的值

[1060. 有序数组中的缺失元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/missing-element-in-sorted-array/)：有一个按照升序排列的整数数组 `nums`，其中每个数字都不相同，给你一个整数 `k`，请你找出并返回从数组最左边开始第 `k` 个缺失数字。👉 [解答](二分/1060%20有序数组中的缺失元素.cc)

我们可以计算出 `nums[i]` 前面缺失元素的个数为 `nums[i] - nums[0] + 1 - (i + 1) = nums[i] - nums[0] - i`，因此我们可以通过二分查找确定比第 `k` 的缺失数字大的数字在 `nums` 数组中的下标：如果 `nums[mid] - nums[0] - mid >= k`，`r = mid - 1`，否则的话 `l = mid + 1`

当二分查找结束的时候我们就找到了 `nums` 中比第 `k` 个缺失数字大的那个元素下标，我们计算到该元素的前一个元素为止一共丢失了多少个数字 `cnt = nums[l - 1] - nums[0] - (l - 1)`

最后第 `k` 个缺失数字就是 `nums[l - 1] + k - cnt`

### 数组查找问题

[4.寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)：给定两个正序数组 `nums1` 和 `nums2` 找出并返回两个正序数组的中位数，时间复杂度要求小于等于 `O(log(m + n))`。👉 [<u>寻找两个正序数组的中位数</u>](./二分/4%20寻找两个正序数组的中位数.cc)

如果题目没有要求时间复杂度小于等于 `O(log(m + n))`，那么可以采用以下两种方法

- 合并 `nums1` 和 `nums2`，然后返回合并之后数组的中位数。时间复杂度 `O(m + n)`，空间复杂度 `O(m + n)`
- 不需要合并，使用两个指针分别指向两个数组的起始位置，每次将元素值较小的那个指针向后移动一个位置。时间复杂度 `O(m + n)`，空间复杂度 `O(1)`

还可以采用二分查找的方法。如果 `m + n` 是奇数，那么中位数是合并之后数组的「第 `(m + n + 1) >> 1`」个元素；如果 `m + n` 是偶数，那么中位数就是「第 `(m + n) >> 1`」和「第 `(m + n) >> 1 + 1`」个元素的平均值。记 `k` 表示需要查找合并之后数组的第 `k` 个元素

我们可以判断 `pivot1 = nums1[k/2 - 1]` 和 `pivot2 = nums2[k/2 - 1]` 的大小

- `if pivot1 < pivot2`，由于 `nums1[k/2 - 1]` 和 `nums2[k/2 - 1]` 前面都有 `k/2 - 1` 个元素，那么 `nums1[k/2 - 1]` 在合并之后数组中的位置最大为 `第 k/2 - 1 + k/2 - 1 + 1 <= k - 1`。因此 `nums1[0...k/2-1]` 全都可以跳过，因此 `nums1` 数组从 `nums1[k/2]` 开始
- 同理 `if pivot1 > pivot2`，跳过 `nums2[0...k/2-1]`，`nums2` 数组从 `nums2[k/2]` 开始
- 如果 `pivot1 == pivot2`，转化为第一种或者第二种其中一种情况处理即可

实际代码处理的时候有一些特殊情况需要处理

- 在计算 `nums1[idx1 + k/2 - 1]` 的时候 `idx1 + k/2 - 1` 有可能越界了，此时 `new_idx1 = min(idx1 + k/2 - 1, m - 1)`；`idx2` 的处理方式同理。这里 `new_idx` 表示需要计算比较的 `pivot` 的下标，而不是下一轮二分查找时候到的起始下标，下一轮二分查找的起始下标等于 `new_idx + 1`
- 由于 `idx` 的更新不总是等于 `idx + k/2 - 1 + 1`，因此 `k` 每次需要删除 `new_idx - old_idx + 1` 个元素，即每次更新 `k -= new_idx - old_idx + 1` 
- 每一轮二分查找之后需要判断 `idx1 == m`，此时返回 `nums2[idx2 + k - 1]`；同理判断 `idx2 == n`，返回 `nums1[idx1 + k - 1]`
- 如果 `k == 1`，返回 `min(nums1[idx1], nums2[idx2])`

[34.在排序数组中查找元素第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)：给你一个按照升序排列的数组 `nums`，和一个目标值 `target`，找出给定目标值在数组中出现的第一个和最后一位置，如果不存在返回 `[-1,-1]`。👉 [<u>在排序数组中查找元素第一个和最后一个位置</u>](二分/34%20在排序数组中查找元素的第一个和最后一个位置.cc)

- 对于第一个出现的位置，当 `nums[mid] == target` 的时候，`r = mid - 1`，最后返回 `l == nums.size() || nums[l] != target ? -1 : l`
- 对于最后一个出现的位置，当 `nums[mid] == target` 的时候，`l = mid + 1`，最后返回 `r < 0 || nums[r] != target ? -1 : r`

[35. 搜索插入位置 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-insert-position/)：给定一个排序数组和一个目标值，在数组中查找目标值，并返回索引，如果没有找到的话返回目标值插入数组中的索引。👉 [解答](二分/35%20搜索插入位置.cc)

查找第一个大于等于目标值索引

[74. 搜索二维矩阵 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-a-2d-matrix/)：给你一个矩阵，其中矩阵的每一行是递增的并且下一行的第一个元素大于前一行的最后一个元素。现在给你一个目标值 `target`，判断矩阵中是否存在目标值。👉 [搜索二维矩阵](二分/74%20搜索二维矩阵.cc)

1. 二分查找。首先对行做二分查找，找到最后一个小于 target 的元素，如果没有找到的话直接返回 false。然后在该行内进行二分查找。时间复杂度 O(logm + logn)
2. Z 字型查找，从矩阵的右上角开始，如果 `matrix[x][y] > taregt` 则说明这一列中不会有答案，我们让 --y；如果 `matrix[x][y] < target` 则说明这一列中可能会有答案，我们让 ++x；如果 `matrix[x][y] == target` 返回 true

[162.寻找峰值]([162. 寻找峰值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-peak-element/))：给你一个整数数组 `nums`，保证 `nums[i] != nums[i + 1]`，请你找出数组中峰值元素的下标。👉 [<u>寻找峰值</u>](二分/162%20寻找峰值.cc)

对于一个给定的元素，如果 `nums[i] < nums[i + 1]` 那么说明 `i` 的右侧必定存在一个峰值，如果 `nums[i] > nums[i + 1]` 那么就说明 `i` 的左侧一定有一个峰值

因此，如果 `nums[i] < nums[i + 1]`，我们就向右遍历；如果 `nums[i] > nums[i + 1]`，我们就向左遍历。这样的话刚好可以用类似二分查找的方法进行遍历

[436. 寻找右区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-right-interval/)：给你一个区间数组 `intervals`，找到每个区间的右侧区间，右侧区间的起始位置刚好大于给定的区间，并且是最小的。👉 [解答](二分/436%20寻找右区间.cc)

首先对 `intervals` 中所有区间的 `start` 和区间的下标 `i` 组合到一起的数组 `vec` 进行排序，然后遍历 `intervals` 通过二分查找找到 `vec` 中第一个大于等于 `intervals[i][1]` 的元素下标 `l`。如果 `l == vec.size()` 则说明不存在右侧区间，否则的话 `vec[l][1]` 就是右侧区间在原数组中的下标

时间复杂度：$O(nlogn)$，空间复杂度：$O(n)$

[658. 找到 K 个最接近的元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-k-closest-elements/)：给定一个排好序的数组 `arr`，两个整数 `x` 和 `k`，从数组中找到最靠近 `x` 的 `k` 个数，返回的结果必须是按升序排好的。👉 [解答](二分/658%20找到K个最接近的元素.cc)

二分查找找到第一个大于等于 `x` 的元素下标，然后使用双指针找到 `k` 个结果

1. 双指针从中间向两端扩展，初始的时候 `pA = l - 1`，`pB = l`，然后不停的判断 `abs(arr[pA] - x) > abs(arr[pB] - x)` 收缩区间
2. 双指针从两端往中间收缩，初始的时候由于并不知道 `arr[l]` 和 `arr[l - 1]` 哪个元素更加接近 `x`，因此 `pA = l - k`，保证 `[pA, l - 1]` 之间的元素都有可能是结果集；`pB = l + k - 1`，保证 `[l, pB]` 之间的元素也都有可能是结果集。然后不断的判断 `abs(arr[pA] - x) > abs(arr[pB] - x)` 收缩区间

时间复杂度：$O(logn + k)$，空间复杂度：$O(k)$

[852. 山脉数组的峰顶索引 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)：找出山脉数组的峰顶元素的下标。👉 [解答](二分/852%20山脉数组的峰顶索引.cc)

判断 `nums[mid]` 和 `nums[mid - 1]`，更新 `l` 和 `r`

[1095. 山脉数组中查找目标值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-in-mountain-array/)：给你一个山脉数组，数组满足前半部分元素严格单调递增，后半部分元素满足严格单调递减。现在请你在不超过 100 次访问数组元素的情况下，找出给定目标值 `target` 在数组中出现的最小下标，数组长度最长为 10000。👉 [山脉数组中查找目标值](二分/1095%20山脉数组中查找目标值.cc)

1. 先使用二分找到山峰元素
2. 在山峰的左半部分二分查找 target
3. 上一步如果没有找到，在山峰的右半部分查找 taregt

### 数学

[50. Pow(x, n) - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/powx-n/)：实现 `pow(x, n)`，计算 `x` 的 `n` 次幂函数。👉 [解答](二分/50%20Pow(x,n).cc)

快速幂。递归计算 `tmp = Pow(x, n / 2)`，如果 `n` 是偶数，返回 `tmp * tmp`，否则的话返回 `tmp * tmp * x`

[69.x的平方根]([69. x 的平方根 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sqrtx/))：给你一个非负整数 `x`，计算并返回 `x` 的算术平方根，结果只保留整数部分。不允许使用内置函数直接计算。👉 [<u>x的平方根</u>](二分/69%20x的平方根.cc)

1. 可以选择直接顺序遍历 `i * i <= x` 找到 `i` 返回即可

可以优化为二分查找 `left = 1, right = x`，每次判断 `mid * mid <= x, left = mid + 1`，否则 `right = mid - 1`，最后返回 `left - 1`

需要注意的是 `mid = (left + right) >> 1` 不能这么计算，这样会溢出；也不能 `mid = left + (right - left) >> 1`，这样会超时；只能 `mid = left + (right - left) / 2`

另外 `mid * mid` 需要先将一个 `mid` 转化为 `uint64_t` 这样两个 `mid` 的乘积就是 `uint64_t` 的，否则的话还是 `int` 类型会溢出

[367. 有效的完全平方数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/valid-perfect-square/)：给你一个正整数 `num`，编写一个函数判断 `num` 是不是完全平方数，不能使用内置库。👉 [解答](二分/367%20有效的完全平方数.cc)

通过二分查找找到第一个 `mid * mid >= num` 的数，判断 `mid * mid` 是否等于 `num`

[441. 排列硬币 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/arranging-coins/)：总共有 `n` 个硬币，对于一个由 `k` 行组成的阶梯，其第 `i` 行正好有 `i` 枚硬币，阶梯的最后一行可能是不完整的，计算可以形成完整阶梯行的总行数。👉 [解答](二分/441%20排列硬币.cc)

二分查找行数，找到最大的硬币数量小于等于 `n` 的行数就是最后可以形成完整阶梯行的总行数，左边界为 `1`，右边界为 `n`

[878. 第 N 个神奇数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/nth-magical-number/)：一个正整数如果能被 `a` 或 `b` 整除，那么它是神奇的，给定三个整数 `n`，`a`，`b`，返回第 `n` 个神奇的数字，答案对 `10^9 + 7` 取模。👉 [解答](二分/878%20第N个神奇数字.cc)

解法和 **1201题** 相同，重点是求 `gcd` 和 `lcm`

[1201. 丑数 III - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ugly-number-iii/)：给你四个整数 `n`，`a`，`b`，`c`，请你设计一个算法来找出第 `n ` 个丑数，丑数是可以被 `a` 或 `b` 或 `c` 整除的正整数。👉 [解答](二分/1201%20丑数III.cc)

可以使用二分查找找到前面刚好有 `n` 个丑数的最小整数，这个整数就是第 `n` 个丑数，具体的查找方法为：对于一个给定的数 $target$，它前面的丑数个数有：
$$
target / a + target/b + target / c - target / LCM(a, b) - target / LCM(b, c) - target / LCM(a, c) + target / LCM(a, b, c)
$$
所以这道题就转变为了求任意两个数和三个数的最小公倍数问题，首先对于两个数的最小公倍数可以通过最小公约数 `gcd(a, b)` 来求出它们的最小公倍数 `lcm(a, b) = a * b / gcd(a, b)`。对于 `a, b, c` 三个数的最小公倍数，可以转化为 `lcm(a, b)` 和 `c` 的最小公倍数，这样就是两个数的最小公倍数

> 丑数问题也可以使用堆来解决

### 随机

[528. 按权重随机选择 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/random-pick-with-weight/)：给你一个从下标 0 开始的正整数数组 `w`，其中 `w[i]` 表示第 `i` 个下标的权重。请你实现函数 `pickIndex`，它可以随机的从范围 `[0, w.length - 1]` 选出一个下标，选取下标 `i` 的概率为 `w[i] / sum(w)`。👉 [解答](二分/528%20按权重随机选择.cc)

我们可以在 `[1, sum(w)]` 上产生随机数 `r`，然后根据 `r` 的范围来输出对应的下标。例如 `[1, 3, 3]`，下标 0 对应的范围是 [1, 1]，下标 1 对应的范围是 [2, 4]，下标 2 对应的范围是 [5, 7]，可以看到每个下标范围的最大值刚好是一个前缀和，我们可以通过二分查找来快速找到大于等于 `r` 的最小的下标

[710. 黑名单中的随机数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/random-pick-with-blacklist/)：给定一个整数 `n` 和一个无重复黑名单整数数组 `blacklist`。设计一种算法，从 `[0, n - 1]` 范围内的任意整数中选取一个未加入黑名单 `blacklist` 的整数，任何在上述范围内切不在黑名单中的整数都应该有同等的可能性被返回。👉 [解答](二分/710%20黑名单中的随机数.cc)

**二分**

我们可以确定在黑名单之外的整数有 `n - blacklist.size()` 个，然后可以产生随机数 `num` 表示黑名单之外的整数的下标，即第 `num` 个

为了找到黑名单之外的第 `num` 个整数，我们可以遍历 `blacklist` 中的每一个数，确定它前面有多少个不在名单中的数，对于 `blacklist[i]`，它前面不在名单中的数有 `blacklist[i] - i` 个

因此只要找到了第一个满足 `blacklist[i] - i >= num` 的整数就可以确定名单外的第 `num` 个数是：`blacklist[i] - (blacklist[i] - i - num + 1) = num + i - 1`（在名单中没有找到满足条件的 `blacklist[i]` 也是一样的）

时间复杂度：初始化的时间复杂度是 $O(mlogm)$，每次 pick 操作的时间复杂度是 $O(logm)$，空间复杂度：$O(logm)$

**哈希**

由于白名单中元素的数量是确定的，有 `n - blacklist.size()` 个。由于 `[0, white_size)`  中有元素是黑名单中的元素，此时可以将这其中存在于黑名单中的元素映射到 `[white_size, n)` 中白名单上的元素，这样我们只需要在 `[0, white_size)` 中产生随机数，然后判断该元素是否存在映射，如果存在的话就返回映射的元素，否则就返回原来的数

具体映射的方法：首先将 `[white_size, n)` 中的所有元素加到 `hash_set` 中，然后遍历 `blacklist` 在 `hash_set` 中删除存在于 `blacklist` 中的元素，此时 `hash_set` 中剩余的元素都是大于 `white_size` 存在于白名单中的元素。然后再次遍历 `blacklist` 如果元素的值小于 `white_size`，则在 `hash_map` 中将该元素按顺序映射到 `hash_set` 中的元素

时间复杂度：初始化的时间复杂度是 $O(m)$，$m$ 是 blacklist 的长度，pick 操作的时间复杂度是 $O(1)$；空间复杂度：$O(m)$

### 动态规划 + 二分

[887. 鸡蛋掉落 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/super-egg-drop/)：给你 `k` 枚相同的鸡蛋，以及一栋有 `n` 层高的楼，现在请你找出鸡蛋在哪一层楼 `f` 掉落刚好会碎。你可以尝试将鸡蛋在某一层扔下，如果鸡蛋没有碎则可以再次尝试，请返回需要尝试的最小次数。👉 [解答](二分/887%20鸡蛋掉落.cc)

初始的时候我们的状态为 `(k, n)` 表示有 `k` 个鸡蛋，`n` 层楼需要尝试。如果我们将鸡蛋从某一层楼 `x` 扔下去，则鸡蛋可能会碎，如果鸡蛋碎了则说明我们需要在 `[1, x-1]` 层楼继续尝试，此时我们的状态变为 `(k - 1, x - 1)`。如果鸡蛋没有碎，则说明我们需要在 `[x + 1, n]` 层楼继续尝试，此时我们的状态变为 `(k, n - x)`

所以对于我们的某个尝试，可能会产生两种结果，两种结果其实是一个递归的子问题。由于 `f` 的值我们并不知道，所以我们需要选择最坏的、也就是需要尝试次数最多的那个结果，这样可以保证无论 `f` 为什么值，计算得到的次数总是最小值。综上分析，如果我们使用 `dp(k, n)` 表示拥有 `k` 个鸡蛋、有 `n` 层楼需要尝试的情况下最少需要多少「尝试次数」才可以找出「鸡蛋刚好会碎的楼层」，则当我们在任意一层 `x` 扔下鸡蛋后 `dp(k, n) = max{dp(k - 1, x - 1), dp(k, n - x)}`，`x` 在 `[1, n]` 之间

`x` 可以在 `[1, n]` 之间任意取值，必定会存在某一个 `x`，`dp(k, n)` 是最小的。所以 `dp(k, n) = min (max{dp(k - 1, x - 1), dp(k, n - x)}), 1 <= x <= n`

`dp(k - 1, x - 1)` 是一个单调递增的函数，`dp(k, n - x)` 是一个单调递减的函数，上述状态转移方程表示成图像就类似下面这样，其中 T1 就是递增的那个函数，T2 就是递减的那个函数，蓝色线条表示的就是状态转移方程函数。我们需要找到这两个函数的交点，就是 `dp(k, n)` 的最小值，由于交点左侧 `T2 - T1 > 0`，交点右侧 `T2 - T1 < 0`，因此可以使用二分查找来找到这个交点左右两侧的离散点，进而确定 `dp(k, n)` 的最小值

<img src="https://assets.leetcode-cn.com/solution-static/887_fig1.jpg" alt="fig1" style="zoom: 25%;" />

[1235. 规划兼职工作 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/)：这里有 `n` 份兼职工作，每份工作预计从 `startTime[i]` 开始到 `endTime[i]` 结束，报酬为 `profit[i]`，重叠的工作不能同时进行，请你计算可以获得的最大报酬。👉 [解答](二分/1235%20规划兼职工作.cc)

使用 $dp[i]$ 表示考虑兼职工作 $i$ 可以获得的最大报酬，此时有两种选择：1. 执行第 $i$ 份工作，那么就需要向前找到第一个不和第 $i$ 份工作重叠的工作 $j$，获得的报酬就是 $dp[j] + profit[i]$；2. 不执行第 $i$ 份工作，获得的报酬和 $dp[i - 1]$ 相等。因此状态转移方程为：
$$
dp[i] = max(dp[j] + profit[i], dp[i - 1])
$$
在计算 `dp` 数组之前我们需要先按照 endTime 对所有工作进行排序，向前查找不重叠的工作可以使用二分查找加快查询速度
[2008. 出租车的最大盈利 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-earnings-from-taxi/)：你驾驶出租车行驶在一条有 `n` 个地点的路上，乘客信息用 `rides` 数组表示，`rides[i] = [starti, endi, tipi]` 表示乘客 `i` 需要从地点 `starti` 出发前往地点 `endi`，愿意支付 `tipi` 元的小费。每一位你选择的乘客 `i`，你可以盈利 `endi - starti + tipi`，你最多同时只能接一个订单，请你计算最多可以盈利多少元。👉 [解答](二分/2008%20出租车的最大盈利.cc)

与 **1235** 一样的解法