## 动态规划

动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类。对于最优解类问题，它的递推性质被称为「最优子结构」，表示当前问题的最优解可以从子问题的最优解中得到；对于计数类问题，当前问题的方案数量，取决于子问题的方案数量

动态规划的五个步骤：

1. 确定 dp 数组下标的含义
2. 确定递推公式
3. dp 数组如何初始化
4. 确定 dp 数组遍历顺序
5. 举例推导 dp 数组

### 基础题目

[509.斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)，👉 [斐波那契数.cc](./动态规划/509%20斐波那契数.cc)
`dp[i] = dp[i - 1] + dp[i - 2]`，其中 `dp[0] = dp[1] = 1`。由于每一个状态只和前面的两个状态有关，因此可以把空间优化成常数级别的

[70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)，👉 [爬楼梯.cc](./动态规划/70%20爬楼梯.cc)
这道题属于 [509.斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/) 的变种，递推公式和 509 题一样

[746.使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)，👉 [使用最小花费爬楼梯.cc](./动态规划/746%20使用最小花费爬楼梯.cc)

`dp[i]` 表示爬到第 `i` 层楼梯需要的开销，可以从 `dp[i - 1]` 和 `dp[i - 2]` 推导出来。如果从第 `i - 1` 层爬上来，那么此时的花费是 `dp[i - 1] + cost[i - 1]`；如果从第 `i - 2` 层爬上来，那么此时的花费是 `dp[i - 2] + cost[i - 2]`。因此 `dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`

[62.不同路径](https://leetcode-cn.com/problems/unique-paths/)：一个机器人位于 m*n 网格的左上角，每次机器人只能向下或者向右移动一步，那么机器人到达右下角总共有多少种不同的路径。👉 [不同路径.cc](./动态规划/62%20不同路径.cc)

`dp[i][j]` 表示到达第 `i` 行、第 `j` 列有多少种不同的路径。由于机器人可以从第 `i - 1` 行、第 `j` 列到达，也可以从第 `i` 行、第 `j - 1` 列到达，所以 `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

- 初始的时候 `dp[i][0]` 和 `dp[0][i]` 都是 1

[63.不同路径II](https://leetcode-cn.com/problems/unique-paths-ii/)：题目描述和 `62题` 一样，区别在于多了障碍物，障碍物是不可到达的。因此在原先的 `dp[i][j]` 的定义下，如果遇到障碍物了，那么 `dp[i][j] = 0`，其余推到过程和 `62题` 一样。👉 [不同路径II.cc](./动态规划/63%20不同路径II.cc)

[343.整数拆分](https://leetcode-cn.com/problems/integer-break/)：给定一个整数 `n`，将其拆分为至少两个正整数的和，求所有拆分数乘积的最大值。👉 [整数拆分.cc](./动态规划/343%20整数拆分.cc)

- 第一种思路：`dp[i]` 表示对于正整数 `i` 能够获得的最大乘积。我们可以将 `i` 拆分为 `i = (i - j) + j, 1 <= j < i`，那么 `dp[i]` 要么等于 `dp[i - j] * j`，要么等于 `(i - j) * j`（这里表示将 `i - j ` 就拆分为自己）。因此遍历所有的 `j`，`dp[i] = max({dp[i], dp[i - j] * j, (i - j) * j})`
  - 该方法时间负载度为 `O(n^2)`
- 官方题解还有一种在上述基础上优化的方法，时间负载度降到 `O(n)`。另外还有一种数学方法

> **补充：整数拆分问题** 将一个正整数 `n` 拆分成至少两个数的和，有多少种方案数
> 例如 `n = 5` 的时候，`5 = 5 = 4 + 1 = 3 + 2 = 3 + 1 + 1 = 2 + 2 + 1 = 2 + 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1`
> 可以定义 `dp(n, k)` 表示将 `n` 拆分为最大的数不超过 `k` 的拆分方案数，则有
>
> 1. 当处理边界情况 `n = 1` 或者 `k = 1` 的时候，`dp(n, k) = 1`
> 2. 当 `n = k` 的时候，如果包含了数字 `k`，则只有一种方案数；如果不包含数字 `k`，则 `dp(n, k) = dp(n, k - 1)`。因此 `dp(n, k)` 是两种情况的和，`dp(n, k) = dp(n, k - 1) + 1`
> 3. 当 `n > k` 的时候，如果包含了数字 `k`，则 `dp(n, k) = dp(n - k, k)`，注意这里 `n - k` 还是有可能大于 `k` 的；如果不包含数字 `k`，则 `dp(n, k) = dp(n, k - 1)`。因此 `dp(n, k) = dp(n - k, k) + dp(n, k - 1)`
> 最后给出一个正整数 n，返回 `dp(n, n - 1)` 即可

[96.不同二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)：给出一个整数 `n`，求出由 1 到 n 的值作为节点的二叉搜索树有多少种。👉 [不同二叉搜索树.cc](./动态规划/96%20不同二叉搜索树.cc)

我们可以知道树的节点由 `[1, 2, 3, ..., n]` 组成，那么可以以其中一个值作为二叉树的根节点，此时左子树就是 `[1, 2, ..., j - 1]` 共有 `j - 1` 个节点，右子树就是 `[j + 1, j + 2, ..., n]` 共有 `n - j` 个节点。如果用 `dp[i]` 表示对于整数 `i` 的拆分个数，那么 `dp[i]` 就等于 `dp[j - 1] * dp[i - j]`；遍历所有的 `1 <= j <= i`，将所有结果都累加起来；即 `dp[i] += dp[j - 1] * dp[i - j], 1 <= j <= i`

- 初始的时候 `dp[0] = dp[1] = 1`

### 背包

#### 0-1 背包

背包容量 `v`，物品价值 `w[]`，每个物品的体积 `v[]`。每个物品只有一件，求该背包能装入的最大价值。
##### 二维数组 DP

`dp[i][j]` 表示从下标 `[0...i]` 物品中挑选物品装入容量为 `j` 的背包，能够装入的最大价值。对于物品 `i` 考虑以下情况：

1. 不放物品 `i`，此时相当于从 `[0...i-1]` 中挑选物品，背包容量还是 `j`。即 `dp[i][j] = dp[i - 1][j]`
2. 放物品 `i`，此时剩余物品是 `[0...i-1]`，背包容量剩余 `j - weight[i]`。因此 `dp[i][j] = dp[i - 1][j - weight[i]] + value[i]`

结合上述两种情况，`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`。

初始化情况：当背包容量为 0 的时候，能够装入的物品价值是 0，即 `dp[i][0] = 0`；另外由于 `dp[i][j]` 需要从 `dp[i - 1][]` 推导而来，因此 `dp[0][]` 也需要初始化，`dp[0][j] = j < weight[0] ? 0 : value[0]`

```c++
void test_2_wei_bag_problem1() {
  vector<int> weight = {1, 3, 4};
  vector<int> value = {15, 20, 30};
  int bagWeight = 4;

  // 二维数组
  vector<vector<int>> dp(weight.size(), vector<int>(bagWeight + 1, 0));

  // 初始化
  for (int j = weight[0]; j <= bagWeight; j++) {
    dp[0][j] = value[0];
  }

  // weight数组的大小 就是物品个数
  for (int i = 1; i < weight.size(); i++) { // 遍历物品
    for (int j = 0; j <= bagWeight; j++) {  // 遍历背包容量
      if (j < weight[i])
        dp[i][j] = dp[i - 1][j];
      else
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
  }

  cout << dp[weight.size() - 1][bagWeight] << endl;
}
```

##### 一维 DP

从前面的递推公式可以看出 `dp[i][j]` 只和 `dp[i - 1][]` 相关，因此可以优化成一维的 DP 数组，即 `dp[j]`。这就是滚动数组的由来，当前层只和上一层的状态相关，可以直接把上一层的状态拷贝到当前层，重复利用。这样 `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`（即考虑装入或者不装入第 `i` 件物品）

另外需要注意，与二维不同的是这里的背包重量遍历顺序必须是从大到小，因为在一维里面是会保存上一次的结果的，而在二维里面本层并不会出现上一层的结果，也就不会被影响到。所以如果一维里面从小到大遍历的话，会导致同一件物品被多次放入，考虑背包容量是 2，物品重量是 1 的情况。如果从小到大 `dp[0] = value[0], dp[1] = dp[0] + value[0]`，就重复放入了；如果从大到小 `dp[2] = dp[1] + value[0] = value[0], dp[1] = value[0]`

另外也不可以先遍历背包在遍历物品，因为一维情况下背包容量是从大到小遍历的，如果放在外层循环的话就表示背包中只放入一件物品了、因为没有前面的状态、而一旦想要先考虑前面的状态就会重复放入物品（只有背包容量从小到大遍历的时候才可以放在外层，因为这样子遍历到大容量背包的时候前面已经考虑过在小容量的背包上放入物品了，也就已经得到子问题的最优解了）

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
  for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
      dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
  }
}
```

[416.分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)：给出一个只包含正整数的非空数组 `nums`，判断 `nums` 能否拆分成两个数组，并且两个数组的元素和相等。👉 [分割等和子集.cc](./动态规划/416%20分割等和子集.cc)

本题可以转化为0-1背包问题，如果 `nums` 数组的所有元素只和记为 `sum`，那么这道题目可以转化为：给出一个容量为 `v = sum / 2` 的背包，以及 `n` 件物品，物品 `i` 的重量是 `nums[i]`，问是否存在一种装法使得刚好可以装满背包。因此我们需要快速判断出能否装满容量为 `v` 的背包，我们可以将物品的价值看作等于物品的重量，这样一来背包装了多重的物品就拥有多大的价值，因此可以先按照0-1背包问题求出最大能装下的价值，然后继续判断该价值是否等于 `v`；如果价值等于 `v` 那说明刚好可以装满，如果小于 `v` 那说明没法刚好装满

> 注意本题不能先排序，然后从前往后计算元素和，如果碰到元素和等于 `nums` 所有元素和的一半就返回 true，当超过 `nums` 所有元素和的一半就返回 false。这种思路是错误的，因为理论上来说该问题是一个 NP 完全问题，没有多项式时间解，因此总可以找出反例，例如 `[2, 2, 1, 1]`

[1049.最后一块石头的重量II](https://leetcode-cn.com/problems/last-stone-weight-ii/)：有一堆石头 `stones[]`，其中 `stones[k]` 表示第 `k` 块石头的重量；如果 `stones[i] <= stones[j]` 则两块石头相撞之后重量较大的那块石头的重量会变成 `stones[j] - stones[i]`。求出这堆石头两两相撞之后最后剩下的那块石头的最小重量。

本质上这道题就是想办法将石头分成质量相近的两堆，这样一来题目所求的值就是两堆石头相撞之后剩余的质量。因此总体执行思路和 *416.分割等和子集* 类似，加入 `sum` 表示所有 `stone` 的重量之和，那么相当于现在有一个容量为 `sum / 2` 的背包，物品的重量是 `stones[i]`，物品的价值也设置为 `stones[i]`（这是为了方便计算），求背包能够装入的最大重量（也就是最大价值），背包装入的重量就是分出来的一堆石头。最后只需返回 `sum - dp[v] - dp[v]` 就是两堆石头相撞的结果。👉 [最后一块石头的重量II.cc](./动态规划/416%20分割等和子集.cc)

[494.目标和](https://leetcode-cn.com/problems/target-sum/)：给你一个整数数组 `nums`，你的任务是给每个元素添加符号 `+` 或者 `-`，然后对 `nums` 中的元素求和，使得新的元素和等于 `target`，添加符号的方案数量。

首先这道题目本质上也是将 `nums` 分成两堆，可以理解为其中一堆的符号是 `-`，另一堆的符号是 `+`，使得两堆数字和做差的绝对值等于 `target` 的绝对值（因为这里 `target` 可能会是负数，但是 `-target` 的题目结果和 `target` 的题目结果是一致的，因此只需要做差结果等于 `abs(target)` 即可）。👉 [目标和.cc](./动态规划/494%20目标和.cc)

- 方法一（回溯）：暴力搜索所有可能的划分方案，最后判断是否满足题目要求即可。唯一需要注意的是，如果题目给出的 `target = 0`，那么最后的结果需要乘以 2，例如 `nums = [1, 2, 1], target = 0`
- 方法二（动态规划）：首先需要明确分成的两堆中有一堆的数字和是 `v = (sum + target) / 2`，因此目标问题就变为装满一个容量为 `v` 的背包有几种装法。使用 `dp[j]` 表示装满容量为 `j` 的背包的装法数量，初始条件 `dp[0] = 1`，因此 `dp[j] += dp[j - nums[i]]`。

> 这里的动态规划虽然是背包问题，但是属于方案数量类别的动态规划问题了，不再是最有子结构类别的动态规划

[474.一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)：给出一个包含二进制字符串的数组 `strs`，以及两个整数 `m` 和 `n`，找出 `strs` 的一个子集，使得其中的 0 的个数不超过 `m`，1 的个数不超过 `n`，并且子集的元素应该尽可能多。返回该子集的元素个数

这里的背包容量是二维的，现在我们有一个容量为 `<m, n>` 的背包，以及一堆物品 `strs`，每件物品的重量是 `<str.get_zero_num(), str.get_one_num()>`，每件物品的价值是 1（因为目标是元素的个数，因此就把元素个数看成价值，所以每个元素贡献的价值都是 1）。从而该问题就转化为一个很普通的0-1背包问题。👉 [一和零.cc](./动态规划/474%20一和零.cc)

我们使用 `dp[j][k]` 表示容量为 `<j, k>` 的背包能够装入的最大价值，那么就有递推公式 `dp[j][k] = max(dp[j][k], dp[j - nums[i].first][k - nums[i].second] + 1)`

[879.盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)：第 `i` 中工作会产生 `profit[i]` 的利润，并且需要 `group[i]` 的人参与，并且每个人一旦参加完一个工作就不能再参加后续的工作。现在给出可以用的总人数 `n`，以及需要产生的最少利润 `minProfit`，求出有多少种工作计划可以选择，使得产生的利润不低于 `minProfit`

本题和 *494.目标和* 一样都是背包问题求方案数量，⚠️ *494.目标和* 求的是刚好装满背包的方案数，而本题求的是大于等于 `minProfit` 的方案数。因此我们可以把 `profit` 也当成一个背包容量的维度，这样一来背包容量就被两个维度限制住了——人数和利润。

使用 `dp[j][k]` 表示背包容量为——最多只允许有 `j` 个人，利润大于等于 `k`，情况下的方案数。因此在该背包容量下的方案数我们可以这样计算：

1. 考虑每一个任务 `i`，它的人数要求是 `group[i]`，能够产生 `profit[i]` 的利润
2. 因此 `dp[j][k] += dp[j - group[i]][]`，注意第二个维度应该怎么确定。第二个维度不能是 `k - profit[i]`，这是因为当带来的收益 `profit[i] > k` 时也是满足要求的，因此此时可以把 `k - profit[i]` 映射到 0。所以最终 `dp[j][k] += dp[j - group[i]][max(0, k - profit[i])]`

👉 [盈利计划.cc](./动态规划/494%20目标和.cc)

```c++
vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1));
for (int i = 0; i <= n; ++i)
  dp[i][0] = 1;
for (int i = 0; i < group.size(); ++i) {
  for (int j = n; j >= group[i]; --j) {
    // 因为可以 profit 超标，因此 k 没有必要将下限设置为 profit[i]
    for (int k = minProfit; k >= 0; --k) {
      dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % MOD;
    }
  }
}
```

> 🎉 小结：当问题可以转化为背包问题的时候
> 
> 1. 需要考虑背包容量的限制因素，背包物品的重量因素
> 2. 问题是最优子结构类问题，还是方案数问题
> 3. 背包物品的价值设置为多少。方案数问题一般不需要考虑价值，最优子结构类问题需要考虑物品的价值；对于尽可能装满背包的容量这类问题，物品的价值就设置为物品的重量；对于尽可能装更多的物品，这类问题，物品价值就设置为 1
> 4. 方案数类问题，背包的容量限制因素由所有的限制条件组成。例如 **494.目标和、879.盈利计划**

#### 完全背包

完全背包的问题描述上和0-1背包的唯一区别就是，完全背包问题中物品的数量是不受限制的。代码实现上和0-1背包的不同之处：

- 0-1背包的一维DP中，背包的遍历顺序是从大到小的，这是为了防止同一件物品被重复多次放入。而完全背包是可以重复添加物品的，因此需要从小到大遍历背包
- 0-1背包的一维DP中，物品必须放在外层遍历，这是因为在前置条件背包从大到小遍历下，如果物品放在内层循环遍历就会变成背包只放入一件物品了（原因在于背包从大到小遍历没有之前小容量背包的状态，具体可以看 **0-1背包** 那里的解释）。而完全背包由于背包就是从小到大遍历的，因此物品无论放在内层还是放在外层都是可以的，只要保证下标 `j` 之前的 `dp[j]` 都是经过计算的就可以了

```c++
// 先遍历物品，在遍历背包
void test_CompletePack() {
  vector<int> weight = {1, 3, 4};
  vector<int> value = {15, 20, 30};
  int bagWeight = 4;
  vector<int> dp(bagWeight + 1, 0);
  for (int i = 0; i < weight.size(); i++) {        // 遍历物品
    for (int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
      dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  cout << dp[bagWeight] << endl;
}
int main() { test_CompletePack(); }
```

```c++
// 先遍历背包，再遍历物品
void test_CompletePack() {
  vector<int> weight = {1, 3, 4};
  vector<int> value = {15, 20, 30};
  int bagWeight = 4;

  vector<int> dp(bagWeight + 1, 0);

  for (int j = 0; j <= bagWeight; j++) {      // 遍历背包容量
    for (int i = 0; i < weight.size(); i++) { // 遍历物品
      if (j - weight[i] >= 0)
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  cout << dp[bagWeight] << endl;
}
int main() { test_CompletePack(); }
```

[518.零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)：给出一堆硬币 `coins`，每个硬币都有无限多个，另外给出一个目标金额 `amount`，求出用 `coins` 凑出 `amount` 的所有硬币 **组合数**

很明显是一个完全背包问题，背包的容量是 `amount`，每件物品的重量是 `coins`，前面有提到过对于方案数类的背包问题不需要考虑物品的价值。我们使用 `dp[j]` 表示凑出额度为 `j` 的金额的方案数量，那么就有 `dp[j] += dp[j - coins[i]]`

这道题还有一个需要注意的地方是，外层必须遍历的是硬币，内层必须遍历背包容量。因为题目求的是组合数，不要求硬币的使用顺序，而如果外层是背包内层是硬币的话就考虑了硬币的顺序了。例如 `coins = [1, 5], amount = 6`，可以知道 `dp[6] += dp[5] + 1` 以及 `dp[6] += dp[1] + 5`；如果先遍历硬币在遍历背包，那么当计算 `dp[5] + 1` 的时候只考虑了使用硬币 1，当计算 `dp[1] + 5` 的时候考虑使用了硬币 `1, 5`，没有考虑 `5, 1` 这种情况在内了；而如果先遍历背包再遍历硬币，那么计算 `dp[5] + 1` 的时候，由于 `dp[5]` 已经考虑过使用硬币 5 了，所以此时考虑了 `全是 1` 、以及 `5, 1` 这两种情况，在计算 `dp[1] + 5` 的时候又考虑了使用 `1, 5` 这种情况。因此这是排列数，相对于组合数来说重复了

> 硬币在外层背包在内层，不考虑顺序；硬币在内层背包在外层，考虑顺序

[377.组合总和IV](https://leetcode-cn.com/problems/combination-sum-iv/)：给出一个由不同整数组成的数组 `nums`，以及一个目标整数 `target`，请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数，顺序不同的序列被视为不同的组合。本题求的是 **排列数**，👉 [组合总和IV.cc](./动态规划/377%20组合总和IV.cc)

这道题和 **518.零钱兑换II** 的唯一区别在于，这道题是需要考虑元素顺序的。因此只需要在 **518.零钱兑换II** 的基础上对换内层和外层循环的顺序即可

> 注：**70.爬楼梯** 那题可以变化为这道题。只需要把每次可以爬的台阶数量设置为 `1, 2, ..., m`，这样以来楼顶的台阶数就是背包的容量，每次可以爬的台阶数量就是物品的重量。所以本质上就和本题一模一样了

[322.零钱兑换](https://leetcode-cn.com/problems/coin-change/)：给出一个整数数组 `coins` 表示拥有的不同面值的硬币，每个硬币都有无限多个，给出一个目标整数 `target`，要求使用 `coins` 中的硬币凑出 `target`，返回需要使用的最少的硬币数量

典型的完全背包问题，只不过现在要求背包装的物品价值尽可能少。我们可以使用 `dp[j]` 表示凑出面值为 `j` 需要的最少的硬币数量，那么当我们遍历到硬币 `coins[i]` 的时候只需要在 `dp[j - coins[i]]` 基础上加 1 即可，即 `dp[j] = min(dp[j], dp[j - conis[i]] + 1)`（当然也可以直接根据背包问题的递推公式来）。

初始条件下设置所有的 `dp[] = INT_MAX - 1`，减 1 是为了后面在计算加 1 的时候不会超过 INT_MAX，另外 `dp[0] = 0`，这样可以在第一次计算 `dp[coins[i]] = min(INT_MAX, dp[coins[i] - coins[i]` 的时候能够得到正确答案。👉 [零钱兑换.cc](./动态规划/322%20零钱兑换.cc)

[279.完全平方数](https://leetcode-cn.com/problems/perfect-squares/)：给定一个整数 `n`，将其分解为若干个完全平方数的和，返回需要使用的完全平方数的最少数量（每个完全平方数可以重复使用）。👉 [完全平方数.cc](./动态规划/279%20完全平方数.cc)

这题本质上就是 **322.硬币兑换**，只不过现在硬币的额度变成了 `[1, 4, 9, ...]`，并且硬币的最大额度 `k` 满足 `k * k <= n`。剩下的解法就和 **322.硬币兑换** 一样了

[139.单词拆分](https://leetcode-cn.com/problems/word-break/)：给出一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典，判断能否用字典中的字符串拼接出 `s`。

这题可以看成一个完全背包问题。使用 `dp[i]` 表示能否使用 `wordDict` 拼接出 `s[0...i-1]`，这样的话假如我们知道了 `s[j...i-1]` 的字串能在 `wordDict` 中找到，那么 `dp[i] = dp[i] | dp[j]`。👉 [单词拆分.cc](./动态规划/139%20单词拆分.cc)

> 判断 `s[j...i-1]` 是否出现在 `wordDict` 的时间负载度是 O(n)，这里可以使用 `set` 实现空间换时间

#### 多重背包

多重背包问题的重点在于，现在每种物品的数量不是一件也不是无数件，而是指定的件数 `k`。因此我们可以把 `k` 件物品拆开，看成0-1背包问题

```c++
/// 方式一：转化为0-1背包问题
void test_multi_pack() {
  vector<int> weight = {1, 3, 4};
  vector<int> value = {15, 20, 30};
  vector<int> nums = {2, 3, 2};
  int bagWeight = 10;
  for (int i = 0; i < nums.size(); i++) {
    while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
      weight.push_back(weight[i]);
      value.push_back(value[i]);
      nums[i]--;
    }
  }

  vector<int> dp(bagWeight + 1, 0);
  for (int i = 0; i < weight.size(); i++) {        // 遍历物品
    for (int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
      dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    for (int j = 0; j <= bagWeight; j++) {
      cout << dp[j] << " ";
    }
    cout << endl;
  }
  cout << dp[bagWeight] << endl;
}
int main() { test_multi_pack(); }
```

```c++
/// 方式二：在内层再加上遍历件数
void test_multi_pack() {
  vector<int> weight = {1, 3, 4};
  vector<int> value = {15, 20, 30};
  vector<int> nums = {2, 3, 2};
  int bagWeight = 10;
  vector<int> dp(bagWeight + 1, 0);

  for (int i = 0; i < weight.size(); i++) {        // 遍历物品
    for (int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
      // 以上为01背包，然后加一个遍历个数
      for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0;
           k++) { // 遍历个数
        dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
      }
    }
    // 打印一下dp数组
    for (int j = 0; j <= bagWeight; j++) {
      cout << dp[j] << " ";
    }
    cout << endl;
  }
  cout << dp[bagWeight] << endl;
}
int main() { test_multi_pack(); }
```

时间复杂度：`O(m * n * k)`，`m` 物品种类，`n` 背包容量，`k` 物品件数

#### 背包总结

能否装满背包

- 416.分割等和子集
- 1049.最后一块石头的重量II

装满背包有几种装法

- 494.目标和
- 518.零钱兑换II
- 377.组合总数IV
- 70.爬楼梯的进阶版

达到目标价值以上有几种装法

- 879.盈利计划

装满背包最大价值

- 474.一和零

装满背包所有物品的最小个数

- 322.零钱兑换
- 279.完全平方数

🎉 小结：当问题可以转化为背包问题的时候

1. 需要考虑背包容量的限制因素，背包物品的重量因素
2. 问题是最优子结构类问题，还是方案数问题
3. 背包物品的价值设置为多少。方案数问题一般不需要考虑价值，最优子结构类问题需要考虑物品的价值；对于尽可能装满背包的容量这类问题，物品的价值就设置为物品的重量；对于尽可能装更多的物品或者其他对物品数量上面提出要求的问题，不管是物品数量尽可能多还是尽可能少，物品价值都设置为 1，例如 **474.一和零**、**322.零钱兑换**、**279.完全平方数**
4. 方案数类问题，背包的容量限制因素由所有的限制条件组成（装满背包、或者至少达到多少的价值）。例如 **494.目标和、879.盈利计划**

### 打家劫舍

[198.打家劫舍](https://leetcode-cn.com/problems/house-robber/)：给出一排房屋内现金的价值，由于报警装置的存在，小偷不能连着偷两个相邻的房子，求小偷能够偷到现金的最大价值。

使用 `dp[i][0]` 表示第 `i` 间房子不偷的情况下能够偷到的最大现金，`dp[i][1]` 表示第 `i` 间房子偷的情况下能够偷到的最大现金。如果第 `i` 间房子不偷，那么第 `i - 1` 间房子可以偷也可以不偷因此 `dp[i][0]` 取它们中的最大值，`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])`；如果第 `i` 间房子偷，那么第 `i - 1` 间房子就不能偷了，因此 `dp[i][1]` 只能在 `i - 1` 不偷的情况下加上第 `i` 间房子的现金，`dp[i][1] = dp[i - 1][0] + nums[i]`。👉 [打家劫舍.cc](./动态规划/打家劫舍/198%20打家劫舍.cc)

另外也可以将 `dp` 数组的维度从二维降至一维，使用 `dp[i]` 表示下标小于等于 `i` 的所有房子时候能够偷到的最大金额。`dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])`

1. 如果不偷第 `i` 间房子，那么此时能够偷到的最大金额就是 `dp[i - 1]`（就是前 `i - 1` 间房子能够偷到的最大金额）
2. 如果偷第 `i` 间房子，那么此时偷到的金额相当于在第 `i - 2` 间房子的基础上再加上第 `i` 间房子的最大价值，即 `dp[i] = dp[i - 2] + nums[i]`。这里不能考虑第 `i - 1` 间房子的基础上加上 `nums[i]`，`dp[i - 1]` 表示下标小于等于 `i - 1` 时候能够偷到的最大金额，因此并不知道此时有没有偷 `i - 1`；如果偷了 `i - 1` 那么就偷不了下标 `i` 了，如果没有偷 `i - 1` 的话，`dp[i - 1] = dp[i - 2]`，因此必须要用 `i - 2` 也只能用 `i - 2`

[213.打家劫舍II](https://leetcode-cn.com/problems/house-robber-ii/)：与 **198.打家劫舍** 的却别在于，现在所有的房子是围成一圈的，这意味着第一间房子和最后一间房子之间是会互相影响的。我们可以分类讨论分别计算，分为：

- 考虑首元素的计算（那么最后一间房子就不可以考虑。在考虑首元素的计算中如果不选择首元素那么计算结果会被包含在「考虑尾元素的计算」，因此在这里可以去掉尾元素）
- 考虑尾元素的计算（那么第一间房子就不可以考虑。在考虑尾元素的计算中如果不选择尾元素，那么计算结果也已经被包含在「考虑首元素的计算」，因此这里可以去掉首元素）

> 对于数组实际上我们可以分为三种情况：去掉最后一个元素；去掉第一个元素；去掉首尾元素。其中第三种情况已经在第一种和第二种情况中被包含了，因此可以去掉
> 👉 [打家劫舍II.cc](./动态规划/打家劫舍/213%20打家劫舍II.cc)

 [337.打家劫舍III](https://leetcode-cn.com/problems/house-robber-iii/)：现在所有的房子形成一棵二叉树，二叉树中直接连接的两个节点不能同时被偷，求能偷到的最大金额。可以用 **198.打家劫舍** 中二维DP数组的方法来求解这道题目，对于某一个节点 `node` 使用 `pair<int, int>` 来表示 <偷这个节点能获得的最大金额, 不偷这个节点能获得的最大金额>。`pair<int, int> dp(TreeNode *node)` 返回该节点的状态

 - 如果不偷这个节点，那么能够偷盗的最大价值就是 `max(dp(node->left).first, dp(node->left).second) + max(dp(node->right).first, dp(node->right).second)` ，即左节点偷或者不偷取最大值加上右节点偷或者不偷取最大值
 - 如果偷这个节点，那么左右节点必须不可以偷，因此能够偷到的最大价值就是 `root->val + dp(node->left).second + dp(node->right).second`

最后返回 `max(first, second)` 就是该节点能够偷到的最大金额。👉 [打家劫舍III.cc](./动态规划/打家劫舍/337%20打家劫舍III.cc)

### 买卖股票的最佳时机

[121.买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)：给定一个 `prices` 数组，`prices[i]` 表示第 `i` 天股票的价格（例如 `[7,1,5,3,6,4]`），你只能选定某一天买入股票并在未来的某一天卖出，求出能获取的最大利润。👉 [买卖股票的最佳时机.cc](./动态规划/股票问题/121%20买卖股票最佳时机.cc)

这道题并不需要动态规划（当然也可以用），使用贪心算法即可，我们只需要找到数组中「谷」->「所有的峰」的最大高度差即可。下面代码中由于 `min_val` 一直记录着 `i` 之前的最小值，因此对于每一个 `prices[i]` 来说总是能够得出在该天卖出股票能够获得的最大利润

```c++
int maxProfit(vector<int>& prices) {
  int res = 0, min_val = prices[0];
  for (int i = 0; i < prices.size(); ++i) {
    res = max(res, prices[i] - min_val);
    min_val = min(min_val, prices[i]);
  }
  return res;
}
```

也可以使用动态规划。使用 `dp[i][0]` 表示第 `i` 天持有股票时候获得的最大利润，`dp[i][1]` 表示第 `i` 天不持有股票时候获得的最大利润，注意第 `i` 天持有股票并不代表是在第 `i` 天买入股票，有可能在前几天就已经买入了，然后一直没有卖出

- `dp[i][0]` 由以下两种状态推导出来
  - 第 `i - 1` 天就持有股票，保持到第 `i` 天，那么 `dp[i][0] = dp[i - 1][0]`
  - 第 `i - 1` 天的时候还没有股票，那么第 `i` 天就需要买入股票，**由于题目要求只能交易一次**，因此 `dp[i][0] = -prices[i]`
- `dp[i][1]` 由以下两种状态推导出来
  - 第 `i - 1` 天持有股票，那么第 `i` 天就需要卖出，此时 `dp[i][1] = dp[i - 1][0] + prices[i]`
  - 第 `i - 1` 天不持有股票，那么 `dp[i][1] = dp[i - 1][1]`

综上，`dp[i][0] = max(dp[i - 1][0], -prices[i])`，`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])`

```c++
int maxProfit(vector<int>& prices) {
  int n = prices.size();
  vector<vector<int>> dp(n, vector<int>(2));
  dp[0][0] = -prices[0]; dp[0][1] = 0;
  for (int i = 1; i < prices.size(); ++i) {
    dp[i][0] = max(dp[i - 1][0], -prices[i]);
    dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
  }
  return dp[n - 1][1];
}
```

[122.买卖股票的最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)：与 **121.买卖股票的最佳时机** 区别在于现在可以多次进行股票买卖，求能获得的最大利润。👉 [买卖股票的最佳时机II.cc](./动态规划/股票问题/122%20买卖股票的最佳时机II.cc)

这题也不需要动态规划（当然也可以用），同样使用贪心算法，**121.买卖股票的最佳时机** 是找到一对高度差最大的「谷」->「峰」，而现在是累加所有「谷」->「谷右边最近的峰」的高度差；也可以理解为累加所有的“上升序列”，因为上升序列就是获得的利润

```c++
int maxProfit(vector<int>& prices) {
  int res = 0;
  for (int i = 1; i < prices.size(); ++i) {
    if (prices[i] > prices[i - 1])
      res += prices[i] - prices[i - 1];
  }
  return res;
}
```

同样的，这道题也可以采用动态规划。与 **121.买卖股票的最佳时机** 一样，使用 `dp[i][0]` 表示第 `i` 天持有股票能够获得的最大利润，`dp[i][1]` 表示第 `i` 天不持有股票能够获得的最大利润。

- `dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])`，**唯一的区别，因为现在股票可以买卖无数次**
- `dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])`

```c++
int maxProfit(vector<int>& prices) {
  int n = prices.size();
  vector<vector<int>> dp(n, vector<int>(2));
  dp[0][0] = -prices[0]; dp[0][1] = 0;
  for (int i = 1; i < n; ++i) {
    dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
    dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
  }
  return dp[n - 1][1];
}
```

[123.买卖股票的最佳时机III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)：与 **121.买卖股票的最佳时机** 的区别在于，现在能够进行股票交易的次数不是 1 次，也不是无数次，而是 2 次。使用动态规划来解决该问题

使用 `dp[i][k][0]` 表示第 `i` 天在最多执行 `k` 次交易的情况下，并且持有股票的时候能够获得的最大利润；`dp[i][k][1]` 表示第 `i` 天最多执行 `k` 次交易的情况下，并且不持有股票时候能够获得的最大利润。本题 `k = [1, 2]`

- `dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k - 1][1] - prices[i])`。第 `i` 天持有股票能够获得利润从以下两种情况中获取
  - 第 `i - 1` 天已经持有股票了，那么说明股票最多可以执行的交易次数肯定和第 `i` 天相同（因为在已经持有的情况下不能买入新的股票），此时 `dp[i][k][0] = dp[i - 1][k][0]`
  - 第 `i - 1` 天不持有股票，由于现在第 `i` 天的最多可以执行的交易次数是 `k`（即开启了新的一轮交易），那么第 `i - 1` 天最多可以执行的交易次数只能是 `k - 1`，所以 `dp[i][k][0] = dp[i - 1][k - 1][1] - prices[i]`
- `dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k][0] + prices[i])`
  - 首先由于第 `i` 天不持有股票，那么就不可能在前面天数的基础上开启一轮新的交易，所以第 `i` 天的最多可以执行的交易次数必定是和前面的几天一样的
  - 如果第 `i - 1` 天持有股票，那么 `dp[i][k][1] = dp[i - 1][k][0] + prices[i]`
  - 如果第 `i - 1` 天不持有股票，那么 `dp[i][k][1] = dp[i - 1][k][1]`

综上 `dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k - 1][1] - prices[i])`，`dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k][0] + prices[i])`。👉 [买卖股票的最佳时机III](./动态规划/股票问题/123%20买卖股票的最佳时机III.cc)

[188.买卖股票的最佳时机IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)：与 **123.买卖股票的最佳时机III** 的区别在于现在指定的最多可以执行的交易次数不是 2，而是 `k`。👉 [买卖股票的最佳时机IV](./动态规划/股票问题/188%20买入股票的最佳时机IV.cc)

直接套用 **123.买卖股票的最佳时机III** 的 `dp` 公式就可以了，那题已经考虑了股票的交易次数是 `k` 了

[309.买卖股票的最佳时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)：本题在 **122.买卖股票的最佳时机II** 的基础上添加了限制，当卖出一支股票之后第二天会变成冷冻期，在冷冻期内不能进行股票的买入操作

大体的动态规划思路和 *122.买卖股票的最佳时机II* 类似。使用 `dp[i][0]` 表示在第 `i` 天持有股票时候能够获得的最大利润，`dp[i][1]` 表示在第 `i` 天不持有股票且在冷冻期能够获得的最大利润，`dp[i][2]` 表示在第 `i` 天不持有股票且不在冷冻期能够获得的最大利润

- `dp[i][0]` 可以从以下两种情况获取
  - 第 `i - 1` 天就持有股票了，那么 `dp[i][0] = dp[i - 1][0]`
  - 第 `i - 1` 天不持有股票并且在冷冻期，这样的话第 `i` 天就不是冷冻期了，那么 `dp[i][0] = dp[i - 1][1] - prices[i]`
- `dp[i][1]` 由于第 `i` 天在冷冻期，因此第 `i` 天做不了任何事情，能够获得的最大利润只能等于第 `i - 1` 天不在冷冻期且不持有股票时候的利润（因为第 `i` 天是冷冻期的话，第 `i - 1 ` 天就不可能是冷冻期了），即 `dp[i][1] = dp[i - 1][2]`
- `dp[i - 1][2]` 能够从以下三种情况获取
  - 第 `i - 1` 天不持有股票并且是冷冻期，那么 `dp[i][2] = dp[i - 1][1]`
  - 第 `i - 1` 天不持有股票并且不是冷冻期，那么 `dp[i][2] = dp[i - 1][2]`
  - 第 `i - 1` 天持有股票，那么 `dp[i][2] = dp[i - 1][0] + prices[i]`

综上所述，`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])`，`dp[i][1] = dp[i - 1][2]`，`dp[i][2] = max({dp[i - 1][1], dp[i - 1][2], dp[i - 1][0] + prices[i]})`。由于 `dp[i][2] >= dp[i][1]`，因此 `dp[i][2] = max(dp[i - 1][2], dp[i - 1][0] + prices[i])`。👉 [买卖股票的最佳时机含冷冻期](./动态规划/股票问题/309%20买卖股票的最佳时机含冷冻期.cc)

> 重点是理解冷冻期这个状态，在这里如果当天进行了股票卖出，那么当前不算冷冻期，第二天才算冷冻期

[714.买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)：本题与 **122.买卖股票的最佳时机II** 的区别在于，现在每一笔交易都需要支付手续费了（可以只考虑在卖出股票的时候支付手续费）。这道题比较简单，直接套用 *122.买卖股票的最佳时机II* 的递推公式就可以了，👉 [买卖股票的最佳时机含手续费](./动态规划/股票问题/714%20买卖股票的最佳时机含手续费.cc)

`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])`，`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)`

### 子序列问题

[53.最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)：给你一个整数数组 `nums`，找出具有最大和连续子数组，返回该子数组的和。这道题有三种解法

1. 贪心算法。我们知道 `nums[i]` 如果小于 0 只会拉低数组的连续和，因此我们使用一个 `cur` 表示当前的连续数组和，如果发现 `cur` 小于 0 了，那么就从 0 重新开始。
2. 动态规划。使用 `dp[i]` 表示以 `nums[i]` 为结尾的子数组的最大和，`dp[i]` 只会从以下两种情况获取。所以 `dp[i] = max(dp[i - 1] + nums[i], nums[i])`
   - `dp[i - 1] + nums[i]`，即 `nums[i]` 前面还有连续的元素
   - `nums[i]`，即以 `nums[i]` 一个元素作为子数组
3. 分治。
   - 对于每一个区间 `[l, r]` 维护四个状态：
     - `lSum` 表示以 `l` 为左端点的最大子段和;
     - `rSum` 表示以 `r` 为右端点的最大子段和;
     - `mSum` 区间 `[l, r]` 的最大子段和;
     - `iSum` 表示区间 `[l, r]` 的区间和
   - 那么原问题的答案就是区间 `[0, nums.size() - 1]` 区间的 `mSum`，其中 `l = 0, r = nums.size() - 1`
   - 对于该问题可以分别求解 `[l, m]` 和 `[m, r]` 的状态，分别记为 `left` 和 `right`
   - 这样区间 `[l, r]` 的状态 `status` 可以从 `left` 和 `right` 推导得到，具体为：
     - `status.iSum = left.iSum + right.iSum`
     - `status.lSum = max(left.lSum, left.iSum + right.lSum)`
     - `status.rSum = max(right.rSum, right.iSum + left.rSum)`
     - `status.mSum = max({left.mSum, right.mSum, left.rSum + right.lSum})`
   - 递归的出口为 `l == r` 的时候，此时四个状态都是 `nums[l]`

> 进阶：输出最大子数组的区间下标。贪心算法在 `count > res` 的时候更新 `resLeft = tmpLeft, resRight = i`，当 `count < 0` 的时候更新 `tmpLeft = i`

[674.最长连续递增子序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)：给出一个数组 `nums`，找出其中最长的并且连续递增的子序列长度。👉 [最长连续递增子序列.cc](./贪心/674%20最长连续递增序列.cc)

这道题比较简答，只需要判断 `nums[i] > nums[i - 1]` 就增加当前连续序列的长度 `cur`，并且更新最后结果 `res = max(res, cur)`，如果 `nums[i] <= nums[i - 1]` 那么 `cur = 1`

[1143.最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)：给定两个字符串 `text1` 和 `text2`，返回两个字符串的最长公共子序列的长度，如果不存在公共子序列就返回 0。👉 [最长公共子序列.cc](./动态规划/1143%20最长公共子序列.cc)

`dp[i][j]` 表示 `text1[0...i]` 和 `text2[0...j]` 之间的最长公共子序列的长度，则有

- 如果 `text1[i] == text2[j]`，那么 `dp[i][j] = dp[i - 1][j - 1] + 1`
- 如果 `text1[i] != text2[j]`，那么 `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`

初始化的时候如果 `text1[i] == text2[0]` 那么 `dp[i][0] = 1`，然后 `i` 之后的所有 `dp[i][0]` 都是 1；同理如果 `text2[j] == text1[0]` 那么 `dp[0][j] = 1`，然后 `j` 之后的所有 `dp[0][j]` 都是 1

[1035.不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)：在两条独立的水平线上写下 `nums1` 和 `nums2` 两个数组中的元素，现在可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 之间的直线，要求 `nums1[i] == nums2[j]` 并且这些线不能相交、同一个数字只能连线一次，求能够绘制出的最大连线数量

这道题本质上就是求 `nums1` 和 `nums2` 的最长公共子序列，因此具体解题方法和 **1143.最长公共子序列** 完全一样

> 小结：对于连续子序列或者子数组来说 `dp[i]` 的定义是以 `nums[i]` 结尾并且需要使用到 `nums[i]` 时候的最优值；而对于不要求连续的子序列或子数组题目来说，`dp[i]` 的定义是 `nums[0...i]` 以来的最优值。⚠️ 这之间的区别
> 
> 对于连续的题目来说最后返回的是 `*max_element(dp.begin(), dp.end())`；对于不要求连续的题目来说，最后返回的是 `dp[n -1]`
>
> 上述的结论可以扩展到二维的 `dp` 数组

[152.乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)：给你一个整数数组 `nums`，请你找出数组中乘积最大的非空连续子数组，并返回该子数组对应的乘积。👉 [乘积最大子数组](动态规划/152%20乘积最大子数组.cc)

如果 `nums[i]` 是负数的话，我们希望用一个负数和 `nums[i]` 相乘；如果 `nums[i]` 是一个正数的话，我们希望用一个正数和 `nums[i]` 相乘。因此使用 `fmax[i]` 记录以 `nums[i]` 结尾的连续乘积的最大值，`fmin[i]` 记录以 `nums[i]` 结尾的连续乘积的最小值

- `fmax[i] = max({fmin[i] * nums[i], fmax[i] * nums[i], nums[i]})`
- `fmin[i] = min({fmin[i] * nums[i], fmax[i] * nums[i], nums[i]})`

也可以用常数空间优化

[392.判断子序列](https://leetcode-cn.com/problems/is-subsequence/)：给定字符串 `s` 和 `t`，判断 `s` 是否是 `t` 的子序列

1. 双指针。指针 `i` 指向 `s` 字符串，指针 `j` 指向 `t` 字符串，对于每一个 `s[i]` 如果 `s[i] == t[j]` 就让 `i++, j++`；否则只有 `j++`
2. 动态规划。使用 `dp[i][j]` 表示 `s[0...i]` 是不是 `t[0...j]` 的子序列，则有
   - 如果 `s[i] == t[j]`，即 `s` 当前遍历到的字符和 `t` 当前的字符相等，那么 `dp[i][j] = dp[i - 1][j - 1]`（只要 `s[0...i-1]` 是 `t[0...j-1]` 的子序列即可）
   - 如果 `s[i] != t[j]`，那么 `dp[i][j] = dp[i][j - 1]`（即只要 `s[0...i]` 是 `t[0...j-1]` 的子序列即可）
3. 动态规划。采用 **1143.最长公共子序列** 的方法，求出 `s` 和 `t` 的最长公共子序列长度 `len`，如果 `len == s.size()` 则说明 `s` 是 `t` 的子序列，否则不是

👉 [判断子序列.cc](./动态规划/392%20判断子序列.cc)

> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
> 
> 可以采用动态规划预处理出 `t` 中字符 `j` 在下标 `i` 之后第一次出现的位置，即使用 `dp[i][j]` 表示字符串 `t` 中、字符 `j` 在下标 `i` 之后第一次出现的位置。`if t[i] == j, d[i][j] = i`，`if t[i] != j, dp[i][j] = dp[i + 1][j]` 即在 `i + 1` 开始往后的位置寻找 `j` 第一次出现的位置。
> 
> 预处理完成之后，只需要遍历字符串 `s` 然后找到 `s[i]` 在 `t` 中出现的位置记为 `add`；然后继续找 `s[i + 1]` 在 `t` 中出现的位置 `add = dp[add][s[i + 1] - 'a']`；如果 `add == t.size()` 即说明不存在，那么就返回 false；当所有的 `s[i]` 都被找到了之后就返回 true

[115.不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)：给定两个字符串 `s` 和 `t`，计算在 `s` 的子序列中 `t` 出现的个数。👉 [不同的子序列.cc](./动态规划/115%20不同的子序列.cc)

使用 `dp[i][j]` 表示 `s[0...i]` 的所有子序列中 `t[0...j]` 出现的个数，对于 `dp[i][j]` 可以从以下两种情况推出来：

1. `s[i] == t[j]`，则这里又可以有两种情况
   1. 使用 `s[i]` 匹配 `t[j]`，此时`dp[i][j]` 的值就是在 `s[0...i-1]` 中匹配到 `t[0...j-1]` 的个数，即 `dp[i][j] = dp[i - 1][j - 1]`
   2. 不使用 `s[i]` 匹配 `t[j]`，此时 `d[[i][j]` 的值就是在 `s[0...i-1]` 中匹配到 `t[0...j]` 的个数，即 `dp[i][j] = dp[i - 1][j]`
2. `s[i] != t[j]`，这时候 `dp[i][j]` 只能等于 `s[0...i-1]` 中匹配到 `t[0...j]` 的个数，即 `dp[i][j] = dp[i - 1][j]`

综上，`dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1], s[i] == t[j]`，`dp[i][j] = dp[i - 1][j], s[i] != t[j]`

[583.两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)：给定两个单词 `word1` 和 `word2`，每次操作可以删除某一个单词中的一个字符，求出最后使得 `word1 == word2` 所需的最小操作步数。👉 [两个字符串的删除操作.cc](./动态规划/583%20两个字符串的删除操作.cc)

有两种动态规划方式：

1. 借助 **1143.最长公共子序列** 方法求出 `word1` 和 `word2` 的公共子序列长度，然后对于 `word1` 来说需要删除的字符个数是 `word1.size() - lcs`，对于 `word2` 来说需要删除的字符个数是 `word2.size() - lcs`。那么本题最后的答案就是 `word1.size() - lcs + word2.size() - lcs`
2. 也可以直接定义 `dp[i][j]` 表示 `word1[0...i]` 到 `word2[0...j]` 所需要的最小删除步数
   - 如果 `word1[i] == word2[j]`，那么从 `word1[0...i]` 到 `word2[0...j]` 的步数就是 `word1[0...i-1]` 到 `word2[0...j-1]` 的步数，即 `dp[i][j] = dp[i - 1][j - 1]`
   - 如果 `word1[i] != word2[j]`，此时如果我们知道 `word1[0...i-1]` 到 `word2[0...j]` 的步数，然后再删除 `word1[i]` 即可；或者如果知道 `word1[0...i]` 到 `word2[0...j-1]` 的步数，然后再删除 `word2[j]` 即可。即 `dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1`

> 第二种方法 `dp` 数组定义成 `(m + 1) * (n + 1)` 更加方便初始化，此时 `dp[0][k] = k, dp[k][0] = k`。具体的 `dp` 数组意思现在表示的是前 `i` 个字符和前 `j` 个字符

[72.编辑距离](https://leetcode-cn.com/problems/edit-distance/)：给定两个字符串 `word1` 和 `word2` 求出从 `word1` 转化为 `word2` 所需的最小步数，每一步可以执行的操作有：删除一个字符、插入一个字符、修改一个字符。👉 [编辑距离.cc](./动态规划/72%20编辑距离.cc)

记 `dp[i][j]` 表示 `word1[0...i-1]` 转化为 `word2[0...j-1]` 所需的最小步数，其递推公式如下：

1. 如果 `word1[i - 1] == word2[j - 1]`，那么不需要执行任何新的操作，此时的最小步数就是从 `word1[0...i-2]` 转化为 `word2[0...j-1]` 的步数，即 `dp[i][j] = dp[i - 1][j - 1]`
2. 如果 `word1[i - 1] != word2[j - 1]`，此时有三种操作可以执行：
   - 首先从 `word1[0...i-2]` 转化为 `word2[0...j-1]`，即先知道 `dp[i - 1][j]`，然后删除字符 `word1[i - 1]`（删除操作）
   - 首先从 `word1[0...i-1]` 转化为 `word1[0...j-2]`，即先知道 `dp[i][j - 1]`，然后在 `word1` 中插入 `word2[j - 1]`（插入操作）
   - 首先从 `word1[0...i-2]` 转化为 `word2[0...j-2]`，即先知道 `dp[i - 1][j - 1]`，然后修改 `word1[i - 1]` 为 `word2[j - 1]`（修改操作）

综上，`dp[i][j] = dp[i - 1][j - 1], word1[i - 1] == word2[j - 1]`，`dp[i][j] = max({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]}) + 1, word1[i - 1] != word2[j - 1]`

[647.回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)：给你一个字符串 `s`，统计并返回字符串中回文字串的数量。👉 [回文字串.cc](./动态规划/647%20回文字串.cc)

- 方法一：动态规划
  - 记 `dp[i][j]` 表示 `s[i...j]` 是不是一个回文串，此时有：如果 `s[i] == s[j]` 那么 `dp[i][j] = dp[i + 1][j - 1]`，否则 `dp[i][j] = false`
  - 初始条件：`dp[i][j] = true, i >= j`
- 方法二：双指针中心扩展，具体实现看下面的代码

```c++
/// 双指针方法
int centralExpand(string &s, int l, int r) {
  int cnt = 0;
  while (l >= 0 && r < s.size() && s[l] == s[r]) {
    --l;
    ++r;
    ++cnt;
  }
  return cnt;
}
int countSubstrings(string s) {
  int res = 0;
  for (int i = 0; i < s.size(); ++i) {
    res += centralExpand(s, i, i);
    res += centralExpand(s, i, i + 1);
  }
  return res;
}
```

[516.最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)：给定一个字符串 `s`，返回其中最长的回文子序列的长度。👉 [最长回文子序列.cc](./动态规划/516%20最长回文子序列.cc)

注意这道题是回文子序列而不是回文串。使用 `dp[i][j]` 表示 `s[i-1...j-1]` 的最长回文子序列的长度，则有：

- 如果 `s[i - 1] == s[j - 1]`，那么 `s[i-1...j-1]` 的最长回文子序列长度可以由 `s[i...j-2]` 获得，即 `dp[i][j] = dp[i + 1][j - 1] + 2`
- 如果 `s[i - 1] != s[j - 1]`，那么 `s[i-1...j-1]` 的最长回文子序列长度要么是 `s[i...j-2]` 的最大长度，要么是 `s[i...j-1]` 的最大长度，即 `dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])`

最后返回 `dp[1][n]` 就是题目所求的最后解

> 小结：有时候 `dp[i]` 表示 `s[0...i-1]`，有时候 `dp[i]` 表示 `s[0...i]`，具体情况需要具体分析。一般来说用来表示 `s[0...i-1]` 在大多数情况下都是可以的，但是如果可以的话用来表示 `s[0...i]` 更好理解一些

### 区间 DP

[5.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)：给你一个字符串 `s`，找到 `s` 中的最长回文子串返回。👉 [<u>最长回文子串</u>](./动态规划/5%20最长回文子串.cc)

- 方法一：动态规划。时间复杂度 `O(n^2)`，空间复杂度 `O(n^2)`
  - 使用 `dp[i][j]` 表示 `s[i-1...j-1]` 是不是一个回文串，边更新 `dp` 数组边记录最长回文串的起始位置和长度

- 方法二：中心扩展。时间复杂度 `O(n^2)`，空间复杂度 `O(1)`
  - 遍历字符串 `s`，对于下标 `i`，从 `i` 和 `(i, i + 1)` 往左右两边扩展，找到最长的回文串


[312. 戳气球 - 力扣（LeetCode）](https://leetcode.cn/problems/burst-balloons/)：有 `n` 个气球，每个气球上面都标有一个数字，这些数字在 `nums` 中。现在要戳破所有气球，戳破第 `i` 个气球可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 的得分，如果 `i - 1` 或者 `i + 1` 越出了数组边界，则 `nums[i - 1]` 或 `nums[i + 1]` 等于 `1`。计算最多可以获得多少得分。👉 [解答](312%20戳气球.cc)

`dp[i][j]` 表示戳破区间 `(i, j)` 可以获得的最大分数，不包括 `i` 和 `j`。这样我们就可以枚举 `k` 在 `i` 到 `j` 之间，气球 `k` 是最后一个戳破的，此时 `dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]`，即戳破 `(i, k)` 和 `(k, j)` 的得分再加上戳破 `k` 的得分。`dp[i][j]` 取所有 `k` 中的最大值

时间复杂度：$O(n^3)$，空间复杂度：$O(n^2)$

### 其他

[剑指 Offer 46. 把数字翻译成字符串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)：给你一个数字按照如下规则翻译为字符串，0-'a'、1-'b'、...、25-'z'，请问有多少种翻译方法。👉 [<u>剑指Offer 46 把数字翻译成字符串</u>](动态规划/剑指Offer%2046%20把数字翻译成字符串.cc)

我们每次可以记录前一个子串中以最后一个字符为结尾的翻译方案数 prev_tail，以及总的翻译方法数 prev_cnt。例如对于 122，我们记录以 2 结尾的翻译方法有 2 个，总的翻译方法数有 3 个。此时对于 1225，以 5 结尾的方案数就等于 3 个，总的方案数等于 3 + 2 = 5

通过前面的分析，可以得到 prev_tail 和 prev_cnt 的转移方程：

```c++
prev_tail = prev_cnt
prev_cnt = prev * 10 + vec[i] < 26 && prev != 0 ? prev_cnt + prev_tail : prev_cnt
```

或者：`f(i) = f(i − 1) + f(i − 2)`

[10.正则表达式](https://leetcode-cn.com/problems/regular-expression-matching/)：给你一个字符串 `s` 和字符串 `p`，请你来实现支持 `.` 和 `*` 的正则表达式匹配。👉 [<u>正则表达式</u>](动态规划/10%20正则表达式.cc)

使用 `dp[i][j]` 表示 `s[0...i-1]` 和 `p[0...j-1]` 能否匹配。有以下几种情况：

1. `p[j - 1] == '*'`，此时可以尝试匹配 `*` 规则，也可以跳过 `*` 规则的匹配

   - `if match(i, j - 1)` 并且尝试匹配 `*` 规则，那么 `s[0...i-1]` 和 `p[0...j-1]` 的匹配就转化为 `s[0...i-2]` 和 `p[0...j-1]` 的匹配，即 `dp[i][j] = dp[i - 1][j]`。例如 `s = "ccc"` 和 `p = "c*"`，此时 `dp[3][2] = dp[2][2]` 
   - 如果跳过 `*` 规则的匹配，那么 `dp[i][j] = dp[i][j - 2]`

2. `p[j - 1] != '*'`，如果 `match(i, j)` 那么 `dp[i][j] = dp[i - 1][j - 1]`，否则 `dp[i][j] = false`

```c++
// 判断 s[i - 1] 和 p[j - 1] 是否匹配
auto match = [&](int i, int j) -> bool {
  if (i == 0)
    return false;
  return s[i - 1] == p[j - 1] || p[j - 1] == '.';
};
```

[221.最大正方形](https://leetcode-cn.com/problems/maximal-square/)：在一个由 `0` 和 `1` 组成的二维矩阵内，找到只包含 `1` 的最大正方形，返回其面积。👉 [<u>最大正方形</u>](动态规划/221%20最大正方形.cc)

使用 `dp[i][j]` 表示以 `matrix[i - 1][j - 1]` 为右下角的正方形的最大边长，则有 `dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])`，即 `(i, j)` 为右下角的正方形的边长取决于 `(i - 1, j - 1)`、`(i - 1, j)` 、`(i, j - 1)` 为右下角的正方形边长，其值为它们中的最小值加一

[1155.掷骰子的N种方法]([1155. 掷骰子的N种方法 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/))：给你 `n` 个一样的骰子，每个骰子上面有 `k` 个面，分别标号为 `1` 到 `k`。给定三个整数 `n`，`k` 和 `target`，求出投掷 `n` 个骰子使得正面朝上的数字之和等于 `target` 的总数，答案对 `1e9 + 7` 去模。👉 [<u>掷骰子的N种方法</u>](动态规划/1155%20掷骰子的N种方法)

这题使用回溯法会超时，因此考虑使用动态规划求解。`dp[i][j]` 表示投掷 `i` 个骰子，其和等于 `j` 的种数

`dp[i][j] += dp[i - 1][j - t]`，即投掷 `i - 1` 个骰子，这 `i - 1` 个骰子的和等于 `j - t`，然后第 `i` 个骰子投出 `t` 这个数即可

初始的时候 `dp[1][i] = 1`，`1 <= i <= min(k, target)`

[32.最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)：给你一个只包含 `(` 和 `)` 的字符串，找出最长有效括号子串的长度。👉 [<u>最长有效括号</u>](动态规划/32%20最长有效括号.cc)

本题有多种解法：

   - 动态规划。时间复杂度 `O(n)`，空间复杂度 `O(n)`
   - 栈。时间复杂度 `O(n)`，空间复杂度 `O(n)`
   - 双指针。时间复杂度 `O(n)`，空间复杂度 `O(1)`

下面介绍动态规划方法的思路。使用 `dp[i]` 表示以 `s[i]` 为右边界的有效括号子串长度，则如果

1. `s[i] == '('`，`dp[i] = 0`
2. `s[i] == ')'`，此时可以判断 `s[i - 1]` 是否为 `(`
   - 如果 `s[i - 1] == '('`，`dp[i]` 就等于以 `s[i - 2]` 为结尾的有效括号子串长度加 2，即 `dp[i] = dp[i - 2] + 2`
   - 如果 `s[i - 1] == ')'`，此时说明以 `s[i]` 结尾的有效括号子串的序列是 `...))`，其中以 `s[i - 1]` 结尾的有效括号子串的起始位置为 `i - dp[i - 1]`，因此进一步的，我们可以判断 `s[i - dp[i - 1] - 1]`
     - 如果 `s[i - dp[i - 1] - 1] == '('`，此时 `s[i - dp[i - 1] - 1]` 和 `s[i]` 可以组成一对括号，那么 `dp[i]` 可以由 `s[i - 1]` 匹配的长度 `dp[i - 1]`、`s[i]` 匹配的长度 2、`s[i - dp[i - 1] - 2]` 匹配的长度 `dp[i - dp[i - 1] - 2]` 组成，即 `dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]`，
     - 如果 `s[i - dp[i - 1] - 1] == ')'`，`dp[i] = 0`

```c++
int longestValidParentheses(string s) {
  int n = s.size();
  vector<int> dp(n);
  for (int i = 0; i < n; ++i) {
    if (s[i] == '(')
      continue;
    if (i - 1 >= 0 && s[i - 1] == '(')
      dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
    else if (i - 1 >= 0 && s[i - 1] == ')') {
      if (i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '(')
        dp[i] = dp[i - 1] + (i - dp[i - 1] - 2 >= 0 ? dp[i - dp[i - 1] - 2] : 0) + 2;
    }
  }
  return !dp.empty() ? *max_element(dp.begin(), dp.end()) : 0;
}
```

下面介绍栈方法的思路。栈顶部的元素表示「最后一个没有被匹配的右括号的下标」

- 当遇到 `(` 时即将其压入栈中
- 当遇到一个右括号的时候就弹出栈顶元素，然后
  - 如果此时栈不为空，那么当前元素的下标减去栈顶元素的下标就是以当前元素结尾的有效括号的长度
  - 如果栈为空，那么就将当前元素压入栈中

```c++
int longestValidParentheses(string s) {
  stack<int> stk;
  // 避免第一个不匹配的 ')' 没有东西弹出
  stk.push(-1);
  int res = 0;
  for (int i = 0; i < s.size(); ++i) {
    if (s[i] == '(')
      stk.push(i);
    else {
      stk.pop();
      if (!stk.empty()) {
        int index = stk.top();
        res = max(res, i - index);
      } else {
        stk.push(i);
      }
    }
  }
  return res;
}
```

下面介绍双指针方法的思路，双指针方法贪心的考虑了以当前字符为结尾的有效括号的长度。每当遇到一个 `(` 就增加 `left` 计数器，每当遇到右括号就增加 `)` 计数器，当 `left = right` 的时候更新最长有效括号的长度，当 `right > left` 的时候重置 `left = right = 0`。但是这样无法求出左括号数量大于右括号数量的情况，例如 `(()`，这时候只需要反向扫描计算一遍即可

```c++
int longestValidParentheses(string s) {
  int left = 0, right = 0, res = 0;
  for (int i = 0; i < s.size(); ++i) {
    if (s[i] == '(')
      left++;
    else if (s[i] == ')')
      right++;

    if (left == right)
      res = max(res, left + right);
    else if (right > left) {
      left = right = 0;
    }
  }
  left = right = 0;
  for (int i = s.size() - 1; i >= 0; --i) {
    if (s[i] == ')')
      right++;
    else if (s[i] == '(')
      left++;

    if (left == right)
      res = max(res, left + right);
    else if (left > right) {
      left = right = 0;
    }
  }
  return res;
}
```